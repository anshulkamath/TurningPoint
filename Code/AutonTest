#include "robot-config.h"
#include <string>
#include <iostream>
#include <vector>
#include <math.h>
#include <sstream>

using namespace std;
using namespace vex;

int wheelDiameter = 4;
double PI = M_PI;

int sgn(double val)
{
    return val > 0 ? 1 : -1;
}

double rampUp(double deltaV, int cycles, int timeSlice)
{
    double currVel = FrontRight.velocity(velocityUnits::pct);
    FrontRight.resetRotation();

    for (int i = 0; i < cycles; i++)
    {
        currVel += deltaV/cycles;
        BackLeft.spin(directionType::fwd, currVel, velocityUnits::pct);
        BackRight.spin(directionType::fwd, currVel, velocityUnits::pct);
        FrontRight.spin(directionType::fwd, currVel, velocityUnits::pct);        
        FrontLeft.spin(directionType::fwd, currVel, velocityUnits::pct);

        task::sleep(timeSlice);
    }

    return FrontRight.rotation(rotationUnits::rev);
}

void drive(double inches, double speed, int cycles = 10, int timeSlice = 50)
{
    double rots = inches / (wheelDiameter * PI);
    rots -= rampUp(speed, cycles, timeSlice);
    FrontRight.resetRotation();
    
    double P = 0, kp = 770;
    double I = 0, ki = 3;
    double D = 0, kd = 5170;
    double error = 0, lError = 0;
    double iThresh = .45;
    double motorPower = 0, lMotorPower = 0;
    
    while (abs(FrontRight.rotation(rotationUnits::rev)) < abs(rots))
    {
        error = rots - FrontRight.rotation(rotationUnits::rev);
        P = error * kp;
        D = (error - lError) * kd;
        
        if (abs(error) < iThresh)
            I += error * ki;
        else
            I = 0;
        
        motorPower = P + I + D;
        
        if (abs(motorPower) > abs(speed))
            motorPower = speed;
        
        BackLeft.spin(directionType::fwd, motorPower, velocityUnits::pct);
        BackRight.spin(directionType::fwd, motorPower, velocityUnits::pct);
        FrontRight.spin(directionType::fwd, motorPower, velocityUnits::pct);        
        FrontLeft.spin(directionType::fwd, motorPower, velocityUnits::pct);
        
        task::sleep(50);        
        lError = error;
    }
    
    BackLeft.stop(brakeType::brake);
    BackRight.stop(brakeType::brake);
    FrontRight.stop(brakeType::brake);
    FrontLeft.stop(brakeType::brake);
}

void turn(double degrees)
{
    double P = 0, kp = 0;
    double I = 0, ki = 0;
    double D = 0, kd = 0;
    double error = 0, lError = 0;
    double iThresh = 1 / (wheelDiameter*PI);
    double motorPower = 0, lMotorPower = 0;
    
    while(gyroscope.value(analogUnits::range12bit))
    {
        
    }
    
}

int main() {
    drive(36, 100);
}
