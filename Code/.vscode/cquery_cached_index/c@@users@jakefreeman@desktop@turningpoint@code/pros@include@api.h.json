16
{"last_modification_time":0,"language":1,"import_file":"c:/users/jakefreeman/desktop/turningpoint/code/pros/include/api.h","args_hash":1014226475389204425,"includes":[{"line":24,"resolved_path":"c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdlib.h"},{"line":26,"resolved_path":"c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdarg.h"},{"line":27,"resolved_path":"c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdint.h"}],"dependencies":["c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdlib.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/crtdefs.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/sal.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/limits.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdarg.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/stdint.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/vadefs.h","c:/program files (x86)/microsoft visual studio 11.0/vc/include/concurrencysal.h"],"skipped_by_preprocessor":["31:1-33:7","1179:1-1181:6","1614:1-1616:7"],"types":[{"id":0,"usr":13838176792705659279,"detailed_name":"<fundamental>","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":[]},{"id":1,"usr":5974164247838781553,"detailed_name":"InterruptHandler","short_name_offset":0,"short_name_size":16,"kind":252,"hover":"typedef void (*InterruptHandler)(unsigned char pin)","comments":"\r\nType definition for interrupt handlers. Such functions must accept one argument indicating\r\nthe pin which changed.","declarations":[],"spell":"332:16-332:32|-1|1|2","extent":"332:1-332:52|-1|1|0","alias_of":0,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["332:16-332:32|-1|1|4","362:61-362:77|-1|1|4"]},{"id":2,"usr":2,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":[]},{"id":3,"usr":18295724775687589292,"detailed_name":"Gyro","short_name_offset":0,"short_name_size":4,"kind":252,"hover":"typedef void * Gyro","comments":"\r\nReference type for an initialized gyro.\r\n\r\nGyro information is stored as an opaque pointer to a structure in memory; as this is a\r\npointer type, it can be safely passed or stored by value.","declarations":[],"spell":"548:16-548:20|-1|1|2","extent":"548:1-548:20|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["548:16-548:20|-1|1|4","559:13-559:17|-1|1|4","579:1-579:5|-1|1|4","588:16-588:20|-1|1|4","597:19-597:23|-1|1|4"]},{"id":4,"usr":4590594376236338479,"detailed_name":"Encoder","short_name_offset":0,"short_name_size":7,"kind":252,"hover":"typedef void * Encoder","comments":"\r\nReference type for an initialized encoder.\r\n\r\nEncoder information is stored as an opaque pointer to a structure in memory; as this is a\r\npointer type, it can be safely passed or stored by value.","declarations":[],"spell":"605:16-605:23|-1|1|2","extent":"605:1-605:23|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["605:16-605:23|-1|1|4","614:16-614:23|-1|1|4","627:1-627:8|-1|1|4","636:19-636:26|-1|1|4","645:22-645:29|-1|1|4"]},{"id":5,"usr":15378017643631099524,"detailed_name":"Ultrasonic","short_name_offset":0,"short_name_size":10,"kind":252,"hover":"typedef void * Ultrasonic","comments":"\r\nReference type for an initialized ultrasonic sensor.\r\n\r\nUltrasonic information is stored as an opaque pointer to a structure in memory; as this is a\r\npointer type, it can be safely passed or stored by value.","declarations":[],"spell":"658:16-658:26|-1|1|2","extent":"658:1-658:26|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["658:16-658:26|-1|1|4","670:19-670:29|-1|1|4","682:1-682:11|-1|1|4","691:25-691:35|-1|1|4"]},{"id":6,"usr":17,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":[]},{"id":7,"usr":18231258388190405228,"detailed_name":"PROS_FILE","short_name_offset":0,"short_name_size":9,"kind":252,"hover":"typedef int PROS_FILE","comments":"\r\nPROS_FILE is an integer referring to a stream for the standard I/O functions.\r\n\r\nPROS_FILE * is the standard library method of referring to a file pointer, even though there is\r\nactually nothing there.","declarations":[],"spell":"750:13-750:22|-1|1|2","extent":"750:1-750:22|-1|1|0","alias_of":6,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["750:13-750:22|-1|1|4","811:16-811:25|-1|1|4","821:20-821:29|-1|1|4","877:13-877:22|-1|1|4","890:12-890:21|-1|1|4","909:10-909:19|-1|1|4","921:12-921:21|-1|1|4","930:11-930:20|-1|1|4","945:33-945:42|-1|1|4","969:1-969:10|-1|1|4","979:33-979:42|-1|1|4","989:22-989:31|-1|1|4","999:31-999:40|-1|1|4","1011:52-1011:61|-1|1|4","1021:11-1021:20|-1|1|4","1029:16-1029:25|-1|1|4","1041:59-1041:68|-1|1|4","1104:13-1104:22|-1|1|4","1158:15-1158:24|-1|1|4","1167:14-1167:23|-1|1|4","1182:55-1182:64|-1|1|4","1194:29-1194:38|-1|1|4","1203:22-1203:31|-1|1|4","1215:17-1215:26|-1|1|4","1221:18-1221:27|-1|1|4"]},{"id":8,"usr":5778908825573379114,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["1011:1-1011:7|-1|1|4","1041:1-1041:7|-1|1|4"]},{"id":9,"usr":5849416891543943526,"detailed_name":"TaskHandle","short_name_offset":0,"short_name_size":10,"kind":252,"hover":"typedef void * TaskHandle","comments":"\r\nType by which tasks are referenced.\r\n\r\nAs this is a pointer type, it can be safely passed or stored by value.","declarations":[],"spell":"1300:16-1300:26|-1|1|2","extent":"1300:1-1300:26|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["1300:16-1300:26|-1|1|4","1336:1-1336:11|-1|1|4","1387:17-1387:27|-1|1|4","1409:27-1409:37|-1|1|4","1416:36-1416:46|-1|1|4","1427:22-1427:32|-1|1|4","1438:17-1438:27|-1|1|4","1454:1-1454:11|-1|1|4","1463:18-1463:28|-1|1|4"]},{"id":10,"usr":3475072824016033923,"detailed_name":"Mutex","short_name_offset":0,"short_name_size":5,"kind":252,"hover":"typedef void * Mutex","comments":"\r\nType by which mutexes are referenced.\r\n\r\nAs this is a pointer type, it can be safely passed or stored by value.","declarations":[],"spell":"1306:16-1306:21|-1|1|2","extent":"1306:1-1306:21|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["1306:16-1306:21|-1|1|4","1520:1-1520:6|-1|1|4","1547:18-1547:23|-1|1|4"]},{"id":11,"usr":14189882228537457731,"detailed_name":"Semaphore","short_name_offset":0,"short_name_size":9,"kind":252,"hover":"typedef void * Semaphore","comments":"\r\nType by which semaphores are referenced.\r\n\r\nAs this is a pointer type, it can be safely passed or stored by value.","declarations":[],"spell":"1312:16-1312:25|-1|1|2","extent":"1312:1-1312:25|-1|1|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["1312:16-1312:25|-1|1|4","1477:1-1477:10|-1|1|4","1506:22-1506:31|-1|1|4"]},{"id":12,"usr":17880397400892477379,"detailed_name":"TaskCode","short_name_offset":0,"short_name_size":8,"kind":252,"hover":"typedef void (*TaskCode)(void *)","comments":"\r\nType for defining task functions. Task functions must accept one parameter of type\r\n\"void *\"; they need not use it.\r\n\r\nFor example:\r\n\r\nvoid MyTask(void *ignore) {\r\n    while (1);\r\n}","declarations":[],"spell":"1323:16-1323:24|-1|1|2","extent":"1323:1-1323:33|-1|1|0","alias_of":0,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["1323:16-1323:24|-1|1|4","1336:23-1336:31|-1|1|4"]}],"funcs":[{"id":0,"usr":15649713314111466463,"detailed_name":"int isAutonomous()","short_name_offset":4,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns true if the robot is in autonomous mode, or false otherwise.\r\n\r\nWhile in autonomous mode, joystick inputs will return a neutral value, but serial port\r\ncommunications (even over VexNET) will still work properly.","declarations":[{"spell":"68:6-68:18|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":1,"usr":11924310206745737757,"detailed_name":"int isEnabled()","short_name_offset":4,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns true if the robot is enabled, or false otherwise.\r\n\r\nWhile disabled via the VEX Competition Switch or VEX Field Controller, motors will not\r\nfunction. However, the digital I/O ports can still be changed, which may indirectly affect\r\nthe robot state (e.g. solenoids). Avoid performing externally visible actions while\r\ndisabled (the kernel should take care of this most of the time).","declarations":[{"spell":"77:6-77:15|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":2,"usr":13740918397534524849,"detailed_name":"int isJoystickConnected(unsigned char joystick)","short_name_offset":4,"short_name_size":19,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns true if a joystick is connected to the specified slot number (1 or 2), or false\r\notherwise.\r\n\r\nUseful for automatically merging joysticks for one operator, or splitting for two. This\r\nfunction does not work properly during initialize() or initializeIO() and can return false\r\npositives. It should be checked once and stored at the beginning of operatorControl().\r\n\r\n@param joystick the joystick slot to check","declarations":[{"spell":"88:6-88:25|-1|1|1","param_spellings":["88:40-88:48"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":3,"usr":9483049048933045379,"detailed_name":"int isOnline()","short_name_offset":4,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns true if a VEX field controller or competition switch is connected, or false\r\notherwise.\r\n\r\nWhen in online mode, the switching between autonomous() and operatorControl() tasks is\r\nmanaged by the PROS kernel.","declarations":[{"spell":"96:6-96:14|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":4,"usr":16955196749859571634,"detailed_name":"int joystickGetAnalog(unsigned char joystick, unsigned char axis)","short_name_offset":4,"short_name_size":17,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the value of a control axis on the VEX joystick. Returns the value from -127 to 127,\r\nor 0 if no joystick is connected to the requested slot.\r\n\r\n@param joystick the joystick slot to check\r\n@param axis one of 1, 2, 3, 4, ACCEL_X, or ACCEL_Y","declarations":[{"spell":"104:5-104:22|-1|1|1","param_spellings":["104:37-104:45","104:61-104:65"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":5,"usr":15259717676604550619,"detailed_name":"int joystickGetDigital(unsigned char joystick, unsigned char buttonGroup, unsigned char button)","short_name_offset":4,"short_name_size":18,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the value of a button on the VEX joystick. Returns true if that button is pressed, or\r\nfalse otherwise. If no joystick is connected to the requested slot, returns false.\r\n\r\n@param joystick the joystick slot to check\r\n@param buttonGroup one of 5, 6, 7, or 8 to request that button as labelled on the joystick\r\n@param button one of JOY_UP, JOY_DOWN, JOY_LEFT, or JOY_RIGHT; requesting JOY_LEFT or\r\nJOY_RIGHT for groups 5 or 6 will cause an undefined value to be returned","declarations":[{"spell":"114:6-114:24|-1|1|1","param_spellings":["114:39-114:47","114:63-114:74","115:16-115:22"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":6,"usr":6080751478684135224,"detailed_name":"unsigned int powerLevelBackup()","short_name_offset":13,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the backup battery voltage in millivolts.\r\n\r\nIf no backup battery is connected, returns 0.","declarations":[{"spell":"121:14-121:30|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":7,"usr":17419066529909152080,"detailed_name":"unsigned int powerLevelMain()","short_name_offset":13,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the main battery voltage in millivolts.\r\n\r\nIn rare circumstances, this method might return 0. Check the output value for reasonability\r\nbefore blindly blasting the user.","declarations":[{"spell":"128:14-128:28|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":8,"usr":2997210326379819081,"detailed_name":"void setTeamName(const char *name)","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nSets the team name displayed to the VEX field control and VEX Firmware Upgrade.\r\n\r\n@param name a string containing the team name; only the first eight characters will be shown","declarations":[{"spell":"134:6-134:17|-1|1|1","param_spellings":["134:30-134:34"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":9,"usr":3608377712931685227,"detailed_name":"int analogCalibrate(unsigned char channel)","short_name_offset":4,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nCalibrates the analog sensor on the specified channel.\r\n\r\nThis method assumes that the true sensor value is not actively changing at this time and\r\ncomputes an average from approximately 500 samples, 1 ms apart, for a 0.5 s period of\r\ncalibration. The average value thus calculated is returned and stored for later calls to the\r\nanalogReadCalibrated() and analogReadCalibratedHR() functions. These functions will return\r\nthe difference between this value and the current sensor value when called.\r\n\r\nDo not use this function in initializeIO(), or when the sensor value might be unstable\r\n(gyro rotation, accelerometer movement).\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange\r\nUSB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery\r\nprovides power to sensors.\r\n\r\n@param channel the channel to calibrate from 1-8\r\n@return the average sensor value computed by this function","declarations":[{"spell":"221:5-221:20|-1|1|1","param_spellings":["221:35-221:42"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":10,"usr":17838590685809643168,"detailed_name":"int analogRead(unsigned char channel)","short_name_offset":4,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nReads an analog input channel and returns the 12-bit value.\r\n\r\nThe value returned is undefined if the analog pin has been switched to a different mode.\r\nThis function is Wiring-compatible with the exception of the larger output range. The\r\nmeaning of the returned value varies depending on the sensor attached.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange\r\nUSB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery\r\nprovides power to sensors.\r\n\r\n@param channel the channel to read from 1-8\r\n@return the analog sensor value, where a value of 0 reflects an input voltage of nearly 0 V\r\nand a value of 4095 reflects an input voltage of nearly 5 V","declarations":[{"spell":"237:5-237:15|-1|1|1","param_spellings":["237:30-237:37"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":11,"usr":9872717420063525368,"detailed_name":"int analogReadCalibrated(unsigned char channel)","short_name_offset":4,"short_name_size":20,"kind":12,"storage":1,"hover":"","comments":"\r\nReads the calibrated value of an analog input channel.\r\n\r\nThe analogCalibrate() function must be run first on that channel. This function is\r\ninappropriate for sensor values intended for integration, as round-off error can accumulate\r\ncausing drift over time. Use analogReadCalibratedHR() instead.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange\r\nUSB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery\r\nprovides power to sensors.\r\n\r\n@param channel the channel to read from 1-8\r\n@return the difference of the sensor value from its calibrated default from -4095 to 4095","declarations":[{"spell":"252:5-252:25|-1|1|1","param_spellings":["252:40-252:47"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":12,"usr":9824019429484558704,"detailed_name":"int analogReadCalibratedHR(unsigned char channel)","short_name_offset":4,"short_name_size":22,"kind":12,"storage":1,"hover":"","comments":"\r\nReads the calibrated value of an analog input channel 1-8 with enhanced precision.\r\n\r\nThe analogCalibrate() function must be run first. This is intended for integrated sensor\r\nvalues such as gyros and accelerometers to reduce drift due to round-off, and should not be\r\nused on a sensor such as a line tracker or potentiometer.\r\n\r\nThe value returned actually has 16 bits of \"precision\", even though the ADC only reads\r\n12 bits, so that errors induced by the average value being between two values come out\r\nin the wash when integrated over time. Think of the value as the true value times 16.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange\r\nUSB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery\r\nprovides power to sensors.\r\n\r\n@param channel the channel to read from 1-8\r\n@return the difference of the sensor value from its calibrated default from -16384 to 16384","declarations":[{"spell":"271:5-271:27|-1|1|1","param_spellings":["271:42-271:49"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":13,"usr":6988363835218732084,"detailed_name":"int digitalRead(unsigned char pin)","short_name_offset":4,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the digital value (1 or 0) of a pin configured as a digital input.\r\n\r\nIf the pin is configured as some other mode, the digital value which reflects the current\r\nstate of the pin is returned, which may or may not differ from the currently set value. The\r\nreturn value is undefined for pins configured as Analog inputs, or for ports in use by a\r\nCommunications interface. This function is Wiring-compatible.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange\r\nUSB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery\r\nprovides power to sensors.\r\n\r\n@param pin the pin to read from 1-26\r\n@return true if the pin is HIGH, or false if it is LOW","declarations":[{"spell":"287:6-287:17|-1|1|1","param_spellings":["287:32-287:35"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":14,"usr":6794181520617010132,"detailed_name":"void digitalWrite(unsigned char pin, int value)","short_name_offset":5,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nSets the digital value (1 or 0) of a pin configured as a digital output.\r\n\r\nIf the pin is configured as some other mode, behavior is undefined. This function is\r\nWiring-compatible.\r\n\r\n@param pin the pin to write from 1-26\r\n@param value an expression evaluating to \"true\" or \"false\" to set the output to HIGH or LOW\r\nrespectively, or the constants HIGH or LOW themselves","declarations":[{"spell":"298:6-298:18|-1|1|1","param_spellings":["298:33-298:36","298:43-298:48"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":15,"usr":11146228526319408947,"detailed_name":"void pinMode(unsigned char pin, unsigned char mode)","short_name_offset":5,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nConfigures the pin as an input or output with a variety of settings.\r\n\r\nDo note that INPUT by default turns on the pull-up resistor, as most VEX sensors are\r\nopen-drain active low. It should not be a big deal for most push-pull sources. This function\r\nis Wiring-compatible.\r\n\r\n@param pin the pin to modify from 1-26\r\n@param mode one of INPUT, INPUT_ANALOG, INPUT_FLOATING, OUTPUT, or OUTPUT_OD","declarations":[{"spell":"309:6-309:13|-1|1|1","param_spellings":["309:28-309:31","309:47-309:51"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":16,"usr":11529800572759692726,"detailed_name":"void ioClearInterrupt(unsigned char pin)","short_name_offset":5,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\nDisables interrupts on the specified pin.\r\n\r\nDisabling interrupts on interrupt pins which are not in use conserves processing time.\r\n\r\n@param pin the pin on which to reset interrupts from 1-9,11-12","declarations":[{"spell":"341:6-341:22|-1|1|1","param_spellings":["341:37-341:40"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":17,"usr":4520198140608383669,"detailed_name":"void ioSetInterrupt(unsigned char pin, unsigned char edges, InterruptHandler handler)","short_name_offset":5,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nSets up an interrupt to occur on the specified pin, and resets any counters or timers\r\nassociated with the pin.\r\n\r\nEach time the specified change occurs, the function pointer passed in will be called with\r\nthe pin that changed as an argument. Enabling pin-change interrupts consumes processing\r\ntime, so it is best to only enable necessary interrupts and to keep the InterruptHandler\r\nfunction short. Pin change interrupts can only be enabled on pins 1-9 and 11-12.\r\n\r\nDo not use API functions such as delay() inside the handler function, as the function will\r\nrun in an ISR where the scheduler is paused and no other interrupts can execute. It is best\r\nto quickly update some state and allow a task to perform the work.\r\n\r\nDo not use this function on pins that are also being used by the built-in ultrasonic or\r\nshaft encoder drivers, or on pins which have been switched to output mode.\r\n\r\n@param pin the pin on which to enable interrupts from 1-9,11-12\r\n@param edges one of INTERRUPT_EDGE_RISING, INTERRUPT_EDGE_FALLING, or INTERRUPT_EDGE_BOTH\r\n@param handler the function to call when the condition is satisfied","declarations":[{"spell":"362:6-362:20|-1|1|1","param_spellings":["362:35-362:38","362:54-362:59","362:78-362:85"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":18,"usr":13144074942603912286,"detailed_name":"int motorGet(unsigned char channel)","short_name_offset":4,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the last set speed of the specified motor channel.\r\n\r\nThis speed may have been set by any task or the PROS kernel itself. This is not guaranteed\r\nto be the speed that the motor is actually running at, or even the speed currently being\r\nsent to the motor, due to latency in the Motor Controller 29 protocol and physical loading.\r\nTo measure actual motor shaft revolution speed, attach a VEX Integrated Motor Encoder or\r\nVEX Quadrature Encoder and use the velocity functions associated with each.\r\n\r\n@param channel the motor channel to fetch from 1-10\r\n@return the speed last sent to this channel; -127 is full reverse and 127 is full forward,\r\nwith 0 being off","declarations":[{"spell":"379:5-379:13|-1|1|1","param_spellings":["379:28-379:35"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":19,"usr":4176356990605629303,"detailed_name":"void motorSet(unsigned char channel, int speed)","short_name_offset":5,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nSets the speed of the specified motor channel.\r\n\r\nDo not use motorSet() with the same channel argument from two different tasks. It is safe to\r\nuse motorSet() with different channel arguments from different tasks.\r\n\r\n@param channel the motor channel to modify from 1-10\r\n@param speed the new signed speed; -127 is full reverse and 127 is full forward, with 0\r\nbeing off","declarations":[{"spell":"390:6-390:14|-1|1|1","param_spellings":["390:29-390:36","390:42-390:47"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":20,"usr":8597586304301303695,"detailed_name":"void motorStop(unsigned char channel)","short_name_offset":5,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nStops the motor on the specified channel, equivalent to calling motorSet() with an argument\r\nof zero.\r\n\r\nThis performs a coasting stop, not an active brake. Since motorStop is similar to\r\nmotorSet(0), see the note for motorSet() about use from multiple tasks.\r\n\r\n@param channel the motor channel to stop from 1-10","declarations":[{"spell":"400:6-400:15|-1|1|1","param_spellings":["400:30-400:37"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":21,"usr":18189449027136871165,"detailed_name":"void motorStopAll()","short_name_offset":5,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nStops all motors; significantly faster than looping through all motor ports and calling\r\nmotorSet(channel, 0) on each one.","declarations":[{"spell":"405:6-405:18|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":22,"usr":2429026716472080737,"detailed_name":"void speakerInit()","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes VEX speaker support.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the\r\nVEX speaker may impact robot performance. Teams may benefit from an if statement that only\r\nenables sound if isOnline() returns false.","declarations":[{"spell":"414:6-414:17|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":23,"usr":6217927314048270823,"detailed_name":"void speakerPlayArray(const char **songs)","short_name_offset":5,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\nPlays up to three RTTTL (Ring Tone Text Transfer Language) songs simultaneously over the\r\nVEX speaker. The audio is mixed to allow polyphonic sound to be played. Many simple songs\r\nare available in RTTTL format online, or compose your own.\r\n\r\nThe song must not be NULL, but unused tracks within the song can be set to NULL. If any of\r\nthe three song tracks is invalid, the result of this function is undefined.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the\r\nVEX speaker may impact robot performance. Teams may benefit from an if statement that only\r\nenables sound if isOnline() returns false.\r\n\r\n@param songs an array of up to three (3) RTTTL songs as string values to play","declarations":[{"spell":"429:6-429:22|-1|1|1","param_spellings":["429:38-429:43"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":24,"usr":9392936909401653205,"detailed_name":"void speakerPlayRtttl(const char *song)","short_name_offset":5,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\nPlays an RTTTL (Ring Tone Text Transfer Language) song over the VEX speaker. Many simple\r\nsongs are available in RTTTL format online, or compose your own.\r\n\r\nThe song must not be NULL. If an invalid song is specified, the result of this function is\r\nundefined.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the\r\nVEX speaker may impact robot performance. Teams may benefit from an if statement that only\r\nenables sound if isOnline() returns false.\r\n\r\n@param song the RTTTL song as a string value to play","declarations":[{"spell":"443:6-443:22|-1|1|1","param_spellings":["443:35-443:39"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":25,"usr":4265457775227675346,"detailed_name":"void speakerShutdown()","short_name_offset":5,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nPowers down and disables the VEX speaker.\r\n\r\nIf a song is currently being played in another task, the behavior of this function is\r\nundefined, since the VEX speaker is not thread safe.","declarations":[{"spell":"450:6-450:21|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":26,"usr":1947823397997096115,"detailed_name":"unsigned int imeInitializeAll()","short_name_offset":13,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes all IMEs.\r\n\r\nIMEs are assigned sequential incrementing addresses, beginning with the first IME on the\r\nchain (closest to the VEX Cortex I2C port). Therefore, a given configuration of IMEs will\r\nalways have the same ID assigned to each encoder. The addresses range from 0 to\r\nIME_ADDR_MAX, so the first encoder gets 0, the second gets 1, ...\r\n\r\nThis function should most likely be used in initialize(). Do not use it in initializeIO() or\r\nat any other time when the scheduler is paused (like an interrupt). Checking the return\r\nvalue of this function is important to ensure that all IMEs are plugged in and responding as\r\nexpected.\r\n\r\nThis function, unlike the other IME functions, is not thread safe. If using imeInitializeAll\r\nto re-initialize encoders, calls to other IME functions might behave unpredictably during\r\nthis function's execution.\r\n\r\n@return the number of IMEs successfully initialized.","declarations":[{"spell":"479:14-479:30|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":27,"usr":5058140733392099284,"detailed_name":"int imeGet(unsigned char address, int *value)","short_name_offset":4,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the current 32-bit count of the specified IME.\r\n\r\nMuch like the count for a quadrature encoder, the tick count is signed and cumulative.\r\nThe value reflects total counts since the last reset. Different VEX Motor Encoders have a\r\ndifferent number of counts per revolution:\r\n\r\n* \\c 240.448 for the 269 IME\r\n* \\c 627.2 for the 393 IME in high torque mode (factory default)\r\n* \\c 392 for the 393 IME in high speed mode\r\n\r\nIf the IME address is invalid, or the IME has not been reset or initialized, the value\r\nstored in *value is undefined.\r\n\r\n@param address the IME address to fetch from 0 to IME_ADDR_MAX\r\n@param value a pointer to the location where the value will be stored (obtained using the\r\n\"&\" operator on the target variable name e.g. <code>imeGet(2, &counts)</code>)\r\n@return true if the count was successfully read and the value stored in *value is valid;\r\nfalse otherwise","declarations":[{"spell":"500:6-500:12|-1|1|1","param_spellings":["500:27-500:34","500:41-500:46"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":28,"usr":6712745979570403258,"detailed_name":"int imeGetVelocity(unsigned char address, int *value)","short_name_offset":4,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the current rotational velocity of the specified IME.\r\n\r\nIn this version of PROS, the velocity is positive if the IME count is increasing and\r\nnegative if the IME count is decreasing. The velocity is in RPM of the internal encoder\r\nwheel. Since checking the IME for its type cannot reveal whether the motor gearing is\r\nhigh speed or high torque (in the 2-Wire Motor 393 case), the user must divide the return\r\nvalue by the number of output revolutions per encoder revolution:\r\n\r\n* \\c 30.056 for the 269 IME\r\n* \\c 39.2 for the 393 IME in high torque mode (factory default)\r\n* \\c 24.5 for the 393 IME in high speed mode\r\n\r\nIf the IME address is invalid, or the IME has not been reset or initialized, the value\r\nstored in *value is undefined.\r\n\r\n@param address the IME address to fetch from 0 to IME_ADDR_MAX\r\n@param value a pointer to the location where the value will be stored (obtained using the\r\n\"&\" operator on the target variable name e.g. <code>imeGetVelocity(2, &counts)</code>)\r\n@return true if the velocity was successfully read and the value stored in *value is valid;\r\nfalse otherwise","declarations":[{"spell":"523:6-523:20|-1|1|1","param_spellings":["523:35-523:42","523:49-523:54"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":29,"usr":11044617649275605252,"detailed_name":"int imeReset(unsigned char address)","short_name_offset":4,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nResets the specified IME's counters to zero.\r\n\r\nThis method can be used while the IME is rotating.\r\n\r\n@param address the IME address to reset from 0 to IME_ADDR_MAX\r\n@return true if the reset succeeded; false otherwise","declarations":[{"spell":"532:6-532:14|-1|1|1","param_spellings":["532:29-532:36"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":30,"usr":18172857203269631721,"detailed_name":"void imeShutdown()","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nShuts down all IMEs on the chain; their addresses return to the default and the stored\r\ncounts and velocities are lost. This function, unlike the other IME functions, is not\r\nthread safe.\r\n\r\nTo use the IME chain again, wait at least 0.25 seconds before using imeInitializeAll again.","declarations":[{"spell":"540:6-540:17|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":31,"usr":17479116462544715734,"detailed_name":"int gyroGet(Gyro gyro)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the current gyro angle in degrees, rounded to the nearest degree.\r\n\r\nThere are 360 degrees in a circle.\r\n\r\n@param gyro the Gyro object from gyroInit() to read\r\n@return the signed and cumulative number of degrees rotated around the gyro's vertical axis\r\nsince the last start or reset","declarations":[{"spell":"559:5-559:12|-1|1|1","param_spellings":["559:18-559:22"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":32,"usr":14613933558036510892,"detailed_name":"Gyro gyroInit(unsigned char port, unsigned short multiplier)","short_name_offset":5,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes and enables a gyro on an analog port.\r\n\r\nNULL will be returned if the port is invalid or the gyro is already in use. Initializing a\r\ngyro implicitly calibrates it and resets its count. Do not move the robot while the gyro is\r\nbeing calibrated. It is suggested to call this function in initialize() and to place the\r\nrobot in its final position before powering it on.\r\n\r\nThe multiplier parameter can tune the gyro to adapt to specific sensors. The default value\r\nat this time is 196; higher values will increase the number of degrees reported for a fixed\r\nactual rotation, while lower values will decrease the number of degrees reported. If your\r\nrobot is consistently turning too far, increase the multiplier, and if it is not turning\r\nfar enough, decrease the multiplier.\r\n\r\n@param port the analog port to use from 1-8\r\n@param multiplier an optional constant to tune the gyro readings; use 0 for the default\r\nvalue\r\n@return a Gyro object to be stored and used for later calls to gyro functions","declarations":[{"spell":"579:6-579:14|-1|1|1","param_spellings":["579:29-579:33","579:50-579:60"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":33,"usr":15748816258394742241,"detailed_name":"void gyroReset(Gyro gyro)","short_name_offset":5,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nResets the gyro to zero.\r\n\r\nIt is safe to use this method while a gyro is enabled. It is not necessary to call this\r\nmethod before stopping or starting a gyro.\r\n\r\n@param gyro the Gyro object from gyroInit() to reset","declarations":[{"spell":"588:6-588:15|-1|1|1","param_spellings":["588:21-588:25"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":34,"usr":8056814633571613465,"detailed_name":"void gyroShutdown(Gyro gyro)","short_name_offset":5,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nStops and disables the gyro.\r\n\r\nGyros use processing power, so disabling unused gyros increases code performance.\r\nThe gyro's position will be retained.\r\n\r\n@param gyro the Gyro object from gyroInit() to stop","declarations":[{"spell":"597:6-597:18|-1|1|1","param_spellings":["597:24-597:28"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":35,"usr":10065823988216684717,"detailed_name":"int encoderGet(Encoder enc)","short_name_offset":4,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the number of ticks recorded by the encoder.\r\n\r\nThere are 360 ticks in one revolution.\r\n\r\n@param enc the Encoder object from encoderInit() to read\r\n@return the signed and cumulative number of counts since the last start or reset","declarations":[{"spell":"614:5-614:15|-1|1|1","param_spellings":["614:24-614:27"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":36,"usr":10765667924168564179,"detailed_name":"Encoder encoderInit(unsigned char portTop, unsigned char portBottom, int reverse)","short_name_offset":8,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes and enables a quadrature encoder on two digital ports.\r\n\r\nNeither the top port nor the bottom port can be digital port 10. NULL will be returned if\r\neither port is invalid or the encoder is already in use. Initializing an encoder implicitly\r\nresets its count.\r\n\r\n@param portTop the \"top\" wire from the encoder sensor with the removable cover side UP\r\n@param portBottom the \"bottom\" wire from the encoder sensor\r\n@param reverse if \"true\", the sensor will count in the opposite direction\r\n@return an Encoder object to be stored and used for later calls to encoder functions","declarations":[{"spell":"627:9-627:20|-1|1|1","param_spellings":["627:35-627:42","627:58-627:68","627:75-627:82"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":37,"usr":2946173113134299622,"detailed_name":"void encoderReset(Encoder enc)","short_name_offset":5,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nResets the encoder to zero.\r\n\r\nIt is safe to use this method while an encoder is enabled. It is not necessary to call this\r\nmethod before stopping or starting an encoder.\r\n\r\n@param enc the Encoder object from encoderInit() to reset","declarations":[{"spell":"636:6-636:18|-1|1|1","param_spellings":["636:27-636:30"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":38,"usr":10275044340215040454,"detailed_name":"void encoderShutdown(Encoder enc)","short_name_offset":5,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nStops and disables the encoder.\r\n\r\nEncoders use processing power, so disabling unused encoders increases code performance.\r\nThe encoder's count will be retained.\r\n\r\n@param enc the Encoder object from encoderInit() to stop","declarations":[{"spell":"645:6-645:21|-1|1|1","param_spellings":["645:30-645:33"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":39,"usr":8316982592527086879,"detailed_name":"int ultrasonicGet(Ultrasonic ult)","short_name_offset":4,"short_name_size":13,"kind":12,"storage":1,"hover":"","comments":"\r\nGets the current ultrasonic sensor value in centimeters.\r\n\r\nIf no object was found or if the ultrasonic sensor is polled while it is pinging and waiting\r\nfor a response, -1 (ULTRA_BAD_RESPONSE) is returned.\r\nIf the ultrasonic sensor was never started, the return value is undefined. Round and fluffy\r\nobjects can cause inaccurate values to be returned.\r\n\r\n@param ult the Ultrasonic object from ultrasonicInit() to read\r\n@return the distance to the nearest object in centimeters","declarations":[{"spell":"670:5-670:18|-1|1|1","param_spellings":["670:30-670:33"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":40,"usr":6533158269121502954,"detailed_name":"Ultrasonic ultrasonicInit(unsigned char portEcho, unsigned char portPing)","short_name_offset":11,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes an ultrasonic sensor on the specified digital ports.\r\n\r\nThe ultrasonic sensor will be polled in the background in concert with the other sensors\r\nregistered using this method. NULL will be returned if either port is invalid or the\r\nultrasonic sensor port is already in use.\r\n\r\n@param portEcho the port connected to the orange cable from 1-9,11-12\r\n@param portPing the port connected to the yellow cable from 1-12\r\n@return an Ultrasonic object to be stored and used for later calls to ultrasonic functions","declarations":[{"spell":"682:12-682:26|-1|1|1","param_spellings":["682:41-682:49","682:65-682:73"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":41,"usr":9266017143736376552,"detailed_name":"void ultrasonicShutdown(Ultrasonic ult)","short_name_offset":5,"short_name_size":18,"kind":12,"storage":1,"hover":"","comments":"\r\nStops and disables the ultrasonic sensor.\r\n\r\nThe last distance it had before stopping will be retained. One more ping operation may occur\r\nbefore the sensor is fully disabled.\r\n\r\n@param ult the Ultrasonic object from ultrasonicInit() to stop","declarations":[{"spell":"691:6-691:24|-1|1|1","param_spellings":["691:36-691:39"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":42,"usr":14046417414301952422,"detailed_name":"int i2cRead(uint8_t addr, uint8_t *data, uint16_t count)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"---- I2C port control ----\r\n\r\ni2cRead - Reads the specified number of data bytes from the specified 7-bit I2C address. The\r\nbytes will be stored at the specified location. Returns true if successful or false if\r\nfailed. If only some bytes could be read, false is still returned.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nSince most I2C devices use an 8-bit register architecture, this method has limited\r\nusefulness. Consider i2cReadRegister instead for the vast majority of applications.","declarations":[{"spell":"706:6-706:13|-1|1|1","param_spellings":["706:22-706:26","706:37-706:41","706:52-706:57"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":43,"usr":17662526144352827681,"detailed_name":"int i2cReadRegister(uint8_t addr, uint8_t reg, uint8_t *value, uint16_t count)","short_name_offset":4,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\ni2cReadRegister - Reads the specified amount of data from the given register address on\r\nthe specified 7-bit I2C address. Returns true if successful or false if failed. If only some\r\nbytes could be read, false is still returned.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nMost I2C devices support an auto-increment address feature, so using this method to read\r\nmore than one byte will usually read a block of sequential registers. Try to merge reads to\r\nseparate registers into a larger read using this function whenever possible to improve code\r\nreliability, even if a few intermediate values need to be thrown away.","declarations":[{"spell":"719:6-719:21|-1|1|1","param_spellings":["719:30-719:34","719:44-719:47","719:58-719:63","719:74-719:79"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":44,"usr":16265506667363587238,"detailed_name":"int i2cWrite(uint8_t addr, uint8_t *data, uint16_t count)","short_name_offset":4,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\ni2cWrite - Writes the specified number of data bytes to the specified 7-bit I2C address.\r\nReturns true if successful or false if failed. If only smoe bytes could be written, false\r\nis still returned.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nSince most I2C devices use an 8-bit register architecture, this method is mostly useful for\r\nsetting the register position (most devices remember the last-used address) or writing a\r\nsequence of bytes to one register address using an auto-increment feature. In these cases,\r\nthe first byte written from the data buffer should have the register address to use.","declarations":[{"spell":"732:6-732:14|-1|1|1","param_spellings":["732:23-732:27","732:38-732:42","732:53-732:58"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":45,"usr":16757136796330563084,"detailed_name":"int i2cWriteRegister(uint8_t addr, uint8_t reg, uint16_t value)","short_name_offset":4,"short_name_size":16,"kind":12,"storage":1,"hover":"","comments":"\r\ni2cWriteRegister - Writes the specified data byte to a register address on the specified\r\n7-bit I2C address. Returns true if successful or false if failed.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nOnly one byte can be written to each register address using this method. While useful for\r\nthe vast majority of I2C operations, writing multiple bytes requires the i2cWrite method.","declarations":[{"spell":"742:6-742:22|-1|1|1","param_spellings":["742:31-742:35","742:45-742:48","742:59-742:64"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":46,"usr":6704289941009473222,"detailed_name":"void usartInit(PROS_FILE *usart, unsigned int baud, unsigned int flags)","short_name_offset":5,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nInitialize the specified serial interface with the given connection parameters.\r\n\r\nI/O to the port is accomplished using the \"standard\" I/O functions such as fputs(),\r\nfprintf(), and fputc().\r\n\r\nRe-initializing an open port may cause loss of data in the buffers. This routine may be\r\nsafely called from initializeIO() or when the scheduler is paused. If I/O is attempted on a\r\nserial port which has never been opened, the behavior will be the same as if the port had\r\nbeen disabled.\r\n\r\n@param usart the port to open, either \"uart1\" or \"uart2\"\r\n@param baud the baud rate to use from 2400 to 1000000 baud\r\n@param flags a bit mask combination of the SERIAL_* flags specifying parity, stop, and data\r\nbits","declarations":[{"spell":"811:6-811:15|-1|1|1","param_spellings":["811:27-811:32","811:47-811:51","811:66-811:71"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":47,"usr":10298716725805039519,"detailed_name":"void usartShutdown(PROS_FILE *usart)","short_name_offset":5,"short_name_size":13,"kind":12,"storage":1,"hover":"","comments":"\r\nDisables the specified USART interface.\r\n\r\nAny data in the transmit and receive buffers will be lost. Attempts to read from the port\r\nwhen it is disabled will deadlock, and attempts to write to it may deadlock depending on\r\nthe state of the buffer.\r\n\r\n@param usart the port to close, either \"uart1\" or \"uart2\"","declarations":[{"spell":"821:6-821:19|-1|1|1","param_spellings":["821:31-821:36"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":48,"usr":1193712170905275223,"detailed_name":"void fclose(PROS_FILE *stream)","short_name_offset":5,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nCloses the specified file descriptor. This function does not work on communication ports;\r\nuse usartShutdown() instead.\r\n\r\n@param stream the file descriptor to close from fopen()","declarations":[{"spell":"877:6-877:12|-1|1|1","param_spellings":["877:24-877:30"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":49,"usr":712337344994872672,"detailed_name":"int fcount(PROS_FILE *stream)","short_name_offset":4,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the number of characters that can be read without blocking (the number of\r\ncharacters available) from the specified stream. This only works for communication ports and\r\nfiles in Read mode; for files in Write mode, 0 is always returned.\r\n\r\nThis function may underestimate, but will not overestimate, the number of characters which\r\nmeet this criterion.\r\n\r\n@param stream the stream to read (stdin, uart1, uart2, or an open file in Read mode)\r\n@return the number of characters which meet this criterion; if this number cannot be\r\ndetermined, returns 0","declarations":[{"spell":"890:5-890:11|-1|1|1","param_spellings":["890:23-890:29"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":50,"usr":11636398030959634053,"detailed_name":"int fdelete(const char *file)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nDelete the specified file if it exists and is not currently open.\r\n\r\nThe file will actually be erased from memory on the next re-boot. A physical power cycle is\r\nrequired to purge deleted files and free their allocated space for new files to be written.\r\nDeleted files are still considered inaccessible to fopen() in Read mode.\r\n\r\n@param file the file name to erase\r\n@return 0 if the file was deleted, or 1 if the file could not be found","declarations":[{"spell":"901:5-901:12|-1|1|1","param_spellings":["901:25-901:29"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":51,"usr":11145877964038468670,"detailed_name":"int feof(PROS_FILE *stream)","short_name_offset":4,"short_name_size":4,"kind":12,"storage":1,"hover":"","comments":"\r\nChecks to see if the specified stream is at its end. This only works for communication ports\r\nand files in Read mode; for files in Write mode, 1 is always returned.\r\n\r\n@param stream the channel to check (stdin, uart1, uart2, or an open file in Read mode)\r\n@return 0 if the stream is not at EOF, or 1 otherwise.","declarations":[{"spell":"909:5-909:9|-1|1|1","param_spellings":["909:21-909:27"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":52,"usr":10081304144771498778,"detailed_name":"int fflush(PROS_FILE *stream)","short_name_offset":4,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nFlushes the data on the specified file channel open in Write mode. This function has no\r\neffect on a communication port or a file in Read mode, as these streams are always flushed as\r\nquickly as possible by the kernel.\r\n\r\nSuccessful completion of an fflush function on a file in Write mode cannot guarantee that\r\nthe file is vaild until fclose() is used on that file descriptor.\r\n\r\n@param stream the channel to flush (an open file in Write mode)\r\n@return 0 if the data was successfully flushed, EOF otherwise","declarations":[{"spell":"921:5-921:11|-1|1|1","param_spellings":["921:23-921:29"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":53,"usr":8512605675371873570,"detailed_name":"int fgetc(PROS_FILE *stream)","short_name_offset":4,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nReads and returns one character from the specified stream, blocking until complete.\r\n\r\nDo not use fgetc() on a VEX LCD port; deadlock may occur.\r\n\r\n@param stream the stream to read (stdin, uart1, uart2, or an open file in Read mode)\r\n@return the next character from 0 to 255, or -1 if no character can be read","declarations":[{"spell":"930:5-930:10|-1|1|1","param_spellings":["930:22-930:28"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":54,"usr":9228588881439717058,"detailed_name":"char *fgets(char *str, int num, PROS_FILE *stream)","short_name_offset":6,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nReads a string from the specified stream, storing the characters into the memory at str.\r\nCharacters will be read until the specified limit is reached, a new line is found, or the\r\nend of file is reached.\r\n\r\nIf the stream is already at end of file (for files in Read mode), NULL will be returned;\r\notherwise, at least one character will be read and stored into str.\r\n\r\n@param str the location where the characters read will be stored\r\n@param num the maximum number of characters to store; at most (num - 1) characters will be\r\nread, with a null terminator ('\\0') automatically appended\r\n@param stream the channel to read (stdin, uart1, uart2, or an open file in Read mode)\r\n@return str, or NULL if zero characters could be read","declarations":[{"spell":"945:7-945:12|-1|1|1","param_spellings":["945:19-945:22","945:28-945:31","945:44-945:50"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":55,"usr":1190329651064351137,"detailed_name":"PROS_FILE *fopen(const char *file, const char *mode)","short_name_offset":11,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nOpens the given file in the specified mode. The file name is truncated to eight characters.\r\nOnly four files can be in use simultaneously in any given time, with at most one of those\r\nfiles in Write mode. This function does not work on communication ports; use usartInit()\r\ninstead.\r\n\r\nmode can be \"r\" or \"w\". Due to the nature of the VEX Cortex memory, the \"r+\", \"w+\", and \"a\"\r\nmodes are not supported by the file system.\r\n\r\nOpening a file that does not exist in Read mode will fail and return NULL, but opening a new\r\nfile in Write mode will create it if there is space. Opening a file that already exists in\r\nWrite mode will destroy the contents and create a new blank file if space is available.\r\n\r\nThere are important considerations when using of the file system on the VEX Cortex. Reading\r\nfrom files is safe, but writing to files should only be performed when robot actuators have\r\nbeen stopped. PROS will attempt to continue to handle events during file writes, but most\r\nuser tasks cannot execute during file writing. Powering down the VEX Cortex mid-write may\r\ncause file system corruption.\r\n\r\n@param file the file name\r\n@param mode the file mode\r\n@return a file descriptor pointing to the new file, or NULL if the file could not be opened","declarations":[{"spell":"969:13-969:18|-1|1|1","param_spellings":["969:31-969:35","969:49-969:53"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":56,"usr":16797718813656150372,"detailed_name":"void fprint(const char *string, PROS_FILE *stream)","short_name_offset":5,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the simple string to the specified stream.\r\n\r\nThis method is much, much faster than fprintf() and does not add a new line like fputs().\r\nDo not use fprint() on a VEX LCD port. Use lcdSetText() instead.\r\n\r\n@param string the string to write\r\n@param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)","declarations":[{"spell":"979:6-979:12|-1|1|1","param_spellings":["979:25-979:31","979:44-979:50"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":57,"usr":8543234271208449349,"detailed_name":"int fputc(int value, PROS_FILE *stream)","short_name_offset":4,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nWrites one character to the specified stream.\r\n\r\nDo not use fputc() on a VEX LCD port. Use lcdSetText() instead.\r\n\r\n@param value the character to write (a value of type \"char\" can be used)\r\n@param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)\r\n@return the character written","declarations":[{"spell":"989:5-989:10|-1|1|1","param_spellings":["989:15-989:20","989:33-989:39"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":58,"usr":5293219031934828147,"detailed_name":"int fputs(const char *string, PROS_FILE *stream)","short_name_offset":4,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nBehaves the same as the \"fprint\" function, and appends a trailing newline (\"\\n\").\r\n\r\nDo not use fputs() on a VEX LCD port. Use lcdSetText() instead.\r\n\r\n@param string the string to write\r\n@param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)\r\n@return the number of characters written, excluding the new line","declarations":[{"spell":"999:5-999:10|-1|1|1","param_spellings":["999:23-999:29","999:42-999:48"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":59,"usr":12932901836596232205,"detailed_name":"size_t fread(void *ptr, size_t size, size_t count, PROS_FILE *stream)","short_name_offset":7,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nReads data from a stream into memory. Returns the number of bytes thus read.\r\n\r\nIf the memory at ptr cannot store (size * count) bytes, undefined behavior occurs.\r\n\r\n@param ptr a pointer to where the data will be stored\r\n@param size the size of each data element to read in bytes\r\n@param count the number of data elements to read\r\n@param stream the stream to read (stdout, uart1, uart2, or an open file in Read mode)\r\n@return the number of bytes successfully read","declarations":[{"spell":"1011:8-1011:13|-1|1|1","param_spellings":["1011:20-1011:23","1011:32-1011:36","1011:45-1011:50","1011:63-1011:69"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":60,"usr":1679502307055251257,"detailed_name":"int fseek(PROS_FILE *stream, long offset, int origin)","short_name_offset":4,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nSeeks within a file open in Read mode. This function will fail when used on a file in Write\r\nmode or on any communications port.\r\n\r\n@param stream the stream to seek within\r\n@param offset the location within the stream to seek\r\n@param origin the reference location for offset: SEEK_CUR, SEEK_SET, or SEEK_END\r\n@return 0 if the seek was successful, or 1 otherwise","declarations":[{"spell":"1021:5-1021:10|-1|1|1","param_spellings":["1021:22-1021:28","1021:39-1021:45","1021:51-1021:57"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":61,"usr":10212340708543611106,"detailed_name":"long ftell(PROS_FILE *stream)","short_name_offset":5,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the current position of the stream. This function works on files in either Read or\r\nWrite mode, but will fail on communications ports.\r\n\r\n@param stream the stream to check\r\n@return the offset of the stream, or -1 if the offset could not be determined","declarations":[{"spell":"1029:10-1029:15|-1|1|1","param_spellings":["1029:27-1029:33"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":62,"usr":9744612718401824183,"detailed_name":"size_t fwrite(const void *ptr, size_t size, size_t count, PROS_FILE *stream)","short_name_offset":7,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nWrites data from memory to a stream. Returns the number of bytes thus written.\r\n\r\nIf the memory at ptr is not as long as (size * count) bytes, undefined behavior occurs.\r\n\r\n@param ptr a pointer to the data to write\r\n@param size the size of each data element to write in bytes\r\n@param count the number of data elements to write\r\n@param stream the stream to write (stdout, uart1, uart2, or an open file in Write mode)\r\n@return the number of bytes successfully written","declarations":[{"spell":"1041:8-1041:14|-1|1|1","param_spellings":["1041:27-1041:30","1041:39-1041:43","1041:52-1041:57","1041:70-1041:76"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":63,"usr":3190121459114055489,"detailed_name":"int getchar()","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nReads and returns one character from \"stdin\", which is the PC debug terminal.\r\n\r\n@return the next character from 0 to 255, or -1 if no character can be read","declarations":[{"spell":"1047:5-1047:12|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":64,"usr":16913615305470395639,"detailed_name":"void print(const char *string)","short_name_offset":5,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the simple string to the debug terminal without formatting.\r\n\r\nThis method is much, much faster than printf().\r\n\r\n@param string the string to write","declarations":[{"spell":"1055:6-1055:11|-1|1|1","param_spellings":["1055:24-1055:30"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":65,"usr":6521939288128384957,"detailed_name":"int putchar(int value)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nWrites one character to \"stdout\", which is the PC debug terminal, and returns the input\r\nvalue.\r\n\r\nWhen using a wireless connection, one may need to press the spacebar before the input is\r\nvisible on the terminal.\r\n\r\n@param value the character to write (a value of type \"char\" can be used)\r\n@return the character written","declarations":[{"spell":"1066:5-1066:12|-1|1|1","param_spellings":["1066:17-1066:22"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":66,"usr":13896014003881902723,"detailed_name":"int puts(const char *string)","short_name_offset":4,"short_name_size":4,"kind":12,"storage":1,"hover":"","comments":"\r\nBehaves the same as the \"print\" function, and appends a trailing newline (\"\\n\").\r\n\r\n@param string the string to write\r\n@return the number of characters written, excluding the new line","declarations":[{"spell":"1073:5-1073:9|-1|1|1","param_spellings":["1073:22-1073:28"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":67,"usr":874801983277746107,"detailed_name":"int fprintf(PROS_FILE *stream, const char *formatString, ...)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the formatted string to the specified output stream.\r\n\r\nThe specifiers supported by this minimalistic printf() function are:\r\n* @c \\%d: Signed integer in base 10 (int)\r\n* @c \\%u: Unsigned integer in base 10 (unsigned int)\r\n* @c \\%x, @c \\%X: Integer in base 16 (unsigned int, int)\r\n* @c \\%p: Pointer (void *, int *, ...)\r\n* @c \\%c: Character (char)\r\n* @c \\%s: Null-terminated string (char *)\r\n* @c \\%%: Single literal percent sign\r\n* @c \\%f: Floating-point number\r\n\r\nSpecifiers can be modified with:\r\n* @c 0: Zero-pad, instead of space-pad\r\n* @c a.b: Make the field at least \"a\" characters wide. If \"b\" is specified for \"%f\", changes the\r\n          number of digits after the decimal point\r\n* @c -: Left-align, instead of right-align\r\n* @c +: Always display the sign character (displays a leading \"+\" for positive numbers)\r\n* @c l: Ignored for compatibility\r\n\r\nInvalid format specifiers, or mismatched parameters to specifiers, cause undefined behavior.\r\nOther characters are written out verbatim. Do not use fprintf() on a VEX LCD port.\r\nUse lcdPrint() instead.\r\n\r\n@param stream the stream to write (stdout, uart1, or uart2)\r\n@param formatString the format string as specified above\r\n@return the number of characters written","declarations":[{"spell":"1104:5-1104:12|-1|1|1","param_spellings":["1104:24-1104:30","1104:44-1104:56"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":68,"usr":18381016531371734093,"detailed_name":"int printf(const char *formatString, ...)","short_name_offset":4,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the formatted string to the debug stream (the PC terminal).\r\n\r\n@param formatString the format string as specified in fprintf()\r\n@return the number of characters written","declarations":[{"spell":"1111:5-1111:11|-1|1|1","param_spellings":["1111:24-1111:36"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":69,"usr":13410737015930399193,"detailed_name":"int snprintf(char *buffer, unsigned long long limit, const char *formatString, ...)","short_name_offset":4,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the formatted string to the string buffer with the specified length limit.\r\n\r\nThe length limit, as per the C standard, includes the trailing null character, so an\r\nargument of 256 will cause a maximum of 255 non-null characters to be printed, and one null\r\nterminator in all cases.\r\n\r\n@param buffer the string buffer where characters can be placed\r\n@param limit the maximum number of characters to write\r\n@param formatString the format string as specified in fprintf()\r\n@return the number of characters stored","declarations":[{"spell":"1124:5-1124:13|-1|1|1","param_spellings":["1124:20-1124:26","1124:35-1124:40","1124:54-1124:66"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":70,"usr":2544375653554166760,"detailed_name":"int sprintf(char *buffer, const char *formatString, ...)","short_name_offset":4,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the formatted string to the string buffer.\r\n\r\nIf the buffer is not big enough to contain the complete formatted output, undefined behavior\r\noccurs. See snprintf() for a safer version of this function.\r\n\r\n@param buffer the string buffer where characters can be placed\r\n@param formatString the format string as specified in fprintf()\r\n@return the number of characters stored","declarations":[{"spell":"1135:5-1135:12|-1|1|1","param_spellings":["1135:19-1135:25","1135:39-1135:51"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":71,"usr":4801161617075317601,"detailed_name":"void lcdClear(PROS_FILE *lcdPort)","short_name_offset":5,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"\r\nClears the LCD screen on the specified port.\r\n\r\nPrinting to a line implicitly overwrites the contents, so clearing should only be required\r\nat startup.\r\n\r\n@param lcdPort the LCD to clear, either uart1 or uart2","declarations":[{"spell":"1158:6-1158:14|-1|1|1","param_spellings":["1158:26-1158:33"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":72,"usr":13198127494853740493,"detailed_name":"void lcdInit(PROS_FILE *lcdPort)","short_name_offset":5,"short_name_size":7,"kind":12,"storage":1,"hover":"","comments":"\r\nInitializes the LCD port, but does not change the text or settings.\r\n\r\nIf the LCD was not initialized before, the text currently on the screen will be undefined.\r\nThe port will not be usable with standard serial port functions until the LCD is stopped.\r\n\r\n@param lcdPort the LCD to initialize, either uart1 or uart2","declarations":[{"spell":"1167:6-1167:13|-1|1|1","param_spellings":["1167:25-1167:32"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":73,"usr":5921786355005320309,"detailed_name":"void lcdPrint(PROS_FILE *lcdPort, unsigned char line, const char *formatString, ...)","short_name_offset":5,"short_name_size":8,"kind":12,"storage":1,"hover":"","comments":"","declarations":[{"spell":"1182:46-1182:54|-1|1|1","param_spellings":["1182:66-1182:73","1182:89-1182:93","1183:14-1183:26"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":74,"usr":16427099226763933776,"detailed_name":"unsigned int lcdReadButtons(PROS_FILE *lcdPort)","short_name_offset":13,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nReads the user button status from the LCD display.\r\n\r\nFor example, if the left and right buttons are pushed, (1 | 4) = 5 will be returned. 0 is\r\nreturned if no buttons are pushed.\r\n\r\n@param lcdPort the LCD to poll, either uart1 or uart2\r\n@return the buttons pressed as a bit mask","declarations":[{"spell":"1194:14-1194:28|-1|1|1","param_spellings":["1194:40-1194:47"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":75,"usr":3771154269209407209,"detailed_name":"void lcdSetBacklight(PROS_FILE *lcdPort, int backlight)","short_name_offset":5,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nSets the specified LCD backlight to be on or off.\r\n\r\nTurning it off will save power but may make it more difficult to read in dim conditions.\r\n\r\n@param lcdPort the LCD to adjust, either uart1 or uart2\r\n@param backlight true to turn the backlight on, or false to turn it off","declarations":[{"spell":"1203:6-1203:21|-1|1|1","param_spellings":["1203:33-1203:40","1203:47-1203:56"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":76,"usr":15603009027707554293,"detailed_name":"void lcdSetText(PROS_FILE *lcdPort, unsigned char line, const char *buffer)","short_name_offset":5,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nPrints the string buffer to the attached LCD.\r\n\r\nThe output string will be truncated as necessary to fit on the LCD screen, 16 characters\r\nwide. This function, like fprint(), is much, much faster than a formatted routine such as\r\nlcdPrint() and consumes less memory.\r\n\r\n@param lcdPort the LCD to write, either uart1 or uart2\r\n@param line the LCD line to write, either 1 or 2\r\n@param buffer the string to write","declarations":[{"spell":"1215:6-1215:16|-1|1|1","param_spellings":["1215:28-1215:35","1215:51-1215:55","1215:69-1215:75"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":77,"usr":7827240590337785338,"detailed_name":"void lcdShutdown(PROS_FILE *lcdPort)","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nShut down the specified LCD port.\r\n\r\n@param lcdPort the LCD to stop, either uart1 or uart2","declarations":[{"spell":"1221:6-1221:17|-1|1|1","param_spellings":["1221:29-1221:36"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":78,"usr":939548941409655017,"detailed_name":"TaskHandle taskCreate(TaskCode taskCode, const unsigned int stackDepth, void *parameters, const unsigned int priority)","short_name_offset":11,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nCreates a new task and add it to the list of tasks that are ready to run.\r\n\r\n@param taskCode the function to execute in its own task\r\n@param stackDepth the number of variables available on the stack (4 * stackDepth bytes will\r\nbe allocated on the Cortex)\r\n@param parameters an argument passed to the taskCode function\r\n@param priority a value from TASK_PRIORITY_LOWEST to TASK_PRIORITY_HIGHEST determining the\r\ninitial priority of the task\r\n@return a handle to the created task, or NULL if an error occurred","declarations":[{"spell":"1336:12-1336:22|-1|1|1","param_spellings":["1336:32-1336:40","1336:61-1336:71","1336:79-1336:89","1337:21-1337:29"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":79,"usr":16147120831799648127,"detailed_name":"void taskDelay(const unsigned long msToDelay)","short_name_offset":5,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nDelays the current task for a given number of milliseconds.\r\n\r\nDelaying for a period of zero will force a reschedule, where tasks of equal priority may be\r\nscheduled if available. The calling task will still be available for immediate rescheduling\r\nonce the other tasks have had their turn or if nothing of equal or higher priority is\r\navailable to be scheduled.\r\n\r\nThis is not the best method to have a task execute code at predefined intervals, as the\r\ndelay time is measured from when the delay is requested. To delay cyclically, use\r\ntaskDelayUntil().\r\n\r\n@param msToDelay the number of milliseconds to wait, with 1000 milliseconds per second","declarations":[{"spell":"1352:6-1352:15|-1|1|1","param_spellings":["1352:36-1352:45"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":80,"usr":894182014457674282,"detailed_name":"void taskDelayUntil(unsigned long *previousWakeTime, const unsigned long cycleTime)","short_name_offset":5,"short_name_size":14,"kind":12,"storage":1,"hover":"","comments":"\r\nDelays the current task until a specified time. The task will be unblocked\r\nat the time *previousWakeTime + cycleTime, and *previousWakeTime will be changed to reflect\r\nthe time at which the task will unblock.\r\n\r\nIf the target time is in the past, no delay occurs, but a reschedule is forced, as if\r\ntaskDelay() was called with an argument of zero. If the sum of cycleTime and\r\n*previousWakeTime overflows or underflows, undefined behavior occurs.\r\n\r\nThis function should be used by cyclical tasks to ensure a constant execution frequency.\r\nWhile taskDelay() specifies a wake time relative to the time at which the function is\r\ncalled, taskDelayUntil() specifies the absolute future time at which it wishes to unblock.\r\nCalling taskDelayUntil with the same cycleTime parameter value in a loop, with\r\npreviousWakeTime referring to a local variable initialized to millis(), will cause the\r\nloop to execute with a fixed period.\r\n\r\n@param previousWakeTime a pointer to the location storing the last unblock time, obtained\r\nby using the \"&\" operator on a variable (e.g. \"taskDelayUntil(&now, 50);\")\r\n@param cycleTime the number of milliseconds to wait, with 1000 milliseconds per second","declarations":[{"spell":"1373:6-1373:20|-1|1|1","param_spellings":["1373:36-1373:52","1373:74-1373:83"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":81,"usr":3329443340693813990,"detailed_name":"void taskDelete(TaskHandle taskToDelete)","short_name_offset":5,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nKills and removes the specified task from the kernel task list.\r\n\r\nDeleting the last task will end the program, possibly leading to undesirable states as\r\nsome outputs may remain in their last set configuration.\r\n\r\nNOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that\r\nhave been deleted. It is therefore important that the idle task is not starved of\r\nprocessing time. Memory allocated by the task code is not automatically freed, and should be\r\nfreed before the task is deleted.\r\n\r\n@param taskToDelete the task to kill; passing NULL kills the current task","declarations":[{"spell":"1387:6-1387:16|-1|1|1","param_spellings":["1387:28-1387:40"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":82,"usr":2052997190618620047,"detailed_name":"unsigned int taskGetCount()","short_name_offset":13,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nDetermines the number of tasks that are currently being managed.\r\n\r\nThis includes all ready, blocked and suspended tasks. A task that has been deleted but not\r\nyet freed by the idle task will also be included in the count. Tasks recently created may\r\ntake one context switch to be counted.\r\n\r\n@return the number of tasks that are currently running, waiting, or suspended","declarations":[{"spell":"1397:14-1397:26|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":83,"usr":14843572523142575739,"detailed_name":"unsigned int taskGetState(TaskHandle task)","short_name_offset":13,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nRetrieves the state of the specified task. Note that the state of tasks which have died may\r\nbe re-used for future tasks, causing the value returned by this function to reflect a\r\ndifferent task than possibly intended in this case.\r\n\r\n@param task Handle to the task to query. Passing NULL will query the current task status\r\n(which will, by definition, be TASK_RUNNING if this call returns)\r\n\r\n@return A value reflecting the task's status, one of the constants TASK_DEAD, TASK_RUNNING,\r\nTASK_RUNNABLE, TASK_SLEEPING, or TASK_SUSPENDED","declarations":[{"spell":"1409:14-1409:26|-1|1|1","param_spellings":["1409:38-1409:42"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":84,"usr":5502089603636133533,"detailed_name":"unsigned int taskPriorityGet(const TaskHandle task)","short_name_offset":13,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nObtains the priority of the specified task.\r\n\r\n@param task the task to check; passing NULL checks the current task\r\n@return the priority of that task from 0 to TASK_MAX_PRIORITIES","declarations":[{"spell":"1416:14-1416:29|-1|1|1","param_spellings":["1416:47-1416:51"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":85,"usr":10726730293696802189,"detailed_name":"void taskPrioritySet(TaskHandle task, const unsigned int newPriority)","short_name_offset":5,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nSets the priority of the specified task.\r\n\r\nA context switch may occur before the function returns if the priority being set is higher\r\nthan the currently executing task and the task being mutated is available to be scheduled.\r\n\r\n@param task the task to change; passing NULL changes the current task\r\n@param newPriority a value between TASK_PRIORITY_LOWEST and TASK_PRIORITY_HIGHEST inclusive\r\nindicating the new task priority","declarations":[{"spell":"1427:6-1427:21|-1|1|1","param_spellings":["1427:33-1427:37","1427:58-1427:69"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":86,"usr":6396946199556684488,"detailed_name":"void taskResume(TaskHandle taskToResume)","short_name_offset":5,"short_name_size":10,"kind":12,"storage":1,"hover":"","comments":"\r\nResumes the specified task.\r\n\r\nA task that has been suspended by one or more calls to taskSuspend() will be made available\r\nfor scheduling again by a call to taskResume(). If the task was not suspended at the time\r\nof the call to taskResume(), undefined behavior occurs.\r\n\r\n@param taskToResume the task to change; passing NULL is not allowed as the current task\r\ncannot be suspended (it is obviously running if this function is called)","declarations":[{"spell":"1438:6-1438:16|-1|1|1","param_spellings":["1438:28-1438:40"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":87,"usr":2403655669826206156,"detailed_name":"TaskHandle taskRunLoop(void (*)(void) fn, const unsigned long increment)","short_name_offset":11,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nStarts a task which will periodically call the specified function.\r\n\r\nIntended for use as a quick-start skeleton for cyclic tasks with higher priority than the\r\n\"main\" tasks. The created task will have priority TASK_PRIORITY_DEFAULT + 1 with the default\r\nstack size. To customize behavior, create a task manually with the specified function.\r\n\r\nThis task will automatically terminate after one further function invocation when the robot\r\nis disabled or when the robot mode is switched.\r\n\r\n@param fn the function to call in this loop\r\n@param increment the delay between successive calls in milliseconds; the taskDelayUntil()\r\nfunction is used for accurate cycle timing\r\n@return a handle to the task, or NULL if an error occurred","declarations":[{"spell":"1454:12-1454:23|-1|1|1","param_spellings":["1454:31-1454:33","1454:62-1454:71"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":88,"usr":6312840476390196285,"detailed_name":"void taskSuspend(TaskHandle taskToSuspend)","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nSuspends the specified task.\r\n\r\nWhen suspended a task will not be scheduled, regardless of whether it might be otherwise\r\navailable to run.\r\n\r\n@param taskToSuspend the task to suspend; passing NULL suspends the current task","declarations":[{"spell":"1463:6-1463:17|-1|1|1","param_spellings":["1463:29-1463:42"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":89,"usr":14114886263842650587,"detailed_name":"Semaphore semaphoreCreate()","short_name_offset":10,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nCreates a semaphore intended for synchronizing tasks. To prevent some critical code from\r\nsimultaneously modifying a shared resource, use mutexes instead.\r\n\r\nSemaphores created using this function can be accessed using the semaphoreTake() and\r\nsemaphoreGive() functions. The mutex functions must not be used on objects of this type.\r\n\r\nThis type of object does not need to have balanced take and give calls, so priority\r\ninheritance is not used. Semaphores can be signalled by an interrupt routine.\r\n\r\n@return a handle to the created semaphore","declarations":[{"spell":"1477:11-1477:26|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":90,"usr":1886609752059214075,"detailed_name":"int semaphoreGive(Semaphore semaphore)","short_name_offset":4,"short_name_size":13,"kind":12,"storage":1,"hover":"","comments":"\r\nSignals a semaphore. Tasks waiting for a signal using semaphoreTake() will be unblocked by\r\nthis call and can continue execution.\r\n\r\nSlow processes can give semaphores when ready, and fast processes waiting to take the\r\nsemaphore will continue at that point.\r\n\r\n@param semaphore the semaphore to signal\r\n@return true if the semaphore was successfully given, or false if the semaphore was not\r\ntaken since the last give","declarations":[{"spell":"1489:6-1489:19|-1|1|1","param_spellings":["1489:30-1489:39"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":91,"usr":8820781699704441199,"detailed_name":"int semaphoreTake(Semaphore semaphore, const unsigned long blockTime)","short_name_offset":4,"short_name_size":13,"kind":12,"storage":1,"hover":"","comments":"\r\nWaits on a semaphore. If the semaphore is already in the \"taken\" state, the current task\r\nwill wait for the semaphore to be signaled. Other tasks can run during this time.\r\n\r\n@param semaphore the semaphore to wait\r\n@param blockTime the maximum time to wait for the semaphore to be given, where -1\r\nspecifies an infinite timeout\r\n@return true if the semaphore was successfully taken, or false if the timeout expired","declarations":[{"spell":"1499:6-1499:19|-1|1|1","param_spellings":["1499:30-1499:39","1499:61-1499:70"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":92,"usr":8840270862616392162,"detailed_name":"void semaphoreDelete(Semaphore semaphore)","short_name_offset":5,"short_name_size":15,"kind":12,"storage":1,"hover":"","comments":"\r\nDeletes the specified semaphore. This function can be dangerous; deleting semaphores being\r\nwaited on by a task may cause deadlock or a crash.\r\n\r\n@param semaphore the semaphore to destroy","declarations":[{"spell":"1506:6-1506:21|-1|1|1","param_spellings":["1506:32-1506:41"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":93,"usr":10001498209523057087,"detailed_name":"Mutex mutexCreate()","short_name_offset":6,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nCreates a mutex intended to allow only one task to use a resource at a time. For signalling\r\nand synchronization, try using semaphores.\r\n\r\nMutexes created using this function can be accessed using the mutexTake() and mutexGive()\r\nfunctions. The semaphore functions must not be used on objects of this type.\r\n\r\nThis type of object uses a priority inheritance mechanism so a task 'taking' a mutex MUST\r\nALWAYS 'give' the mutex back once the mutex is no longer required.\r\n\r\n@return a handle to the created mutex","declarations":[{"spell":"1520:7-1520:18|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":94,"usr":16903502333558930379,"detailed_name":"int mutexGive(Mutex mutex)","short_name_offset":4,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nRelinquishes a mutex so that other tasks can use the resource it guards. The mutex must be\r\nheld by the current task using a corresponding call to mutexTake.\r\n\r\n@param mutex the mutex to release\r\n@return true if the mutex was released, or false if the mutex was not already held","declarations":[{"spell":"1528:6-1528:15|-1|1|1","param_spellings":["1528:22-1528:27"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":95,"usr":2344020631271083263,"detailed_name":"int mutexTake(Mutex mutex, const unsigned long blockTime)","short_name_offset":4,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nRequests a mutex so that other tasks cannot simultaneously use the resource it guards.\r\nThe mutex must not already be held by the current task. If another task already\r\nholds the mutex, the function will wait for the mutex to be released. Other tasks can run\r\nduring this time.\r\n\r\n@param mutex the mutex to request\r\n@param blockTime the maximum time to wait for the mutex to be available, where -1\r\nspecifies an infinite timeout\r\n@return true if the mutex was successfully taken, or false if the timeout expired","declarations":[{"spell":"1540:6-1540:15|-1|1|1","param_spellings":["1540:22-1540:27","1540:49-1540:58"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":96,"usr":387819519041506268,"detailed_name":"void mutexDelete(Mutex mutex)","short_name_offset":5,"short_name_size":11,"kind":12,"storage":1,"hover":"","comments":"\r\nDeletes the specified mutex. This function can be dangerous; deleting semaphores being\r\nwaited on by a task may cause deadlock or a crash.\r\n\r\n@param mutex the mutex to destroy","declarations":[{"spell":"1547:6-1547:17|-1|1|1","param_spellings":["1547:24-1547:29"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":97,"usr":13582985887125507576,"detailed_name":"void delay(const unsigned long time)","short_name_offset":5,"short_name_size":5,"kind":12,"storage":1,"hover":"","comments":"\r\nWiring-compatible alias of taskDelay().\r\n\r\n@param time the duration of the delay in milliseconds (1 000 milliseconds per second)","declarations":[{"spell":"1554:6-1554:11|-1|1|1","param_spellings":["1554:32-1554:36"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":98,"usr":13005946304084334862,"detailed_name":"void delayMicroseconds(const unsigned long us)","short_name_offset":5,"short_name_size":17,"kind":12,"storage":1,"hover":"","comments":"\r\nWait for approximately the given number of microseconds.\r\n\r\nThe method used for delaying this length of time may vary depending on the argument.\r\nThe current task will always be delayed by at least the specified period, but possibly much\r\nmore depending on CPU load. In general, this function is less reliable than delay(). Using\r\nthis function in a loop may hog processing time from other tasks.\r\n\r\n@param us the duration of the delay in microseconds (1 000 000 microseconds per second)","declarations":[{"spell":"1565:6-1565:23|-1|1|1","param_spellings":["1565:44-1565:46"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":99,"usr":18255793912538251741,"detailed_name":"unsigned long micros()","short_name_offset":14,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the number of microseconds since Cortex power-up. There are 10^6 microseconds in a\r\nsecond, so as a 32-bit integer, this will overflow and wrap back to zero every two hours or\r\nso.\r\n\r\nThis function is Wiring-compatible.\r\n\r\n@return the number of microseconds since the Cortex was turned on or the last overflow","declarations":[{"spell":"1575:15-1575:21|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":100,"usr":8635978937798820089,"detailed_name":"unsigned long millis()","short_name_offset":14,"short_name_size":6,"kind":12,"storage":1,"hover":"","comments":"\r\nReturns the number of milliseconds since Cortex power-up. There are 1000 milliseconds in a\r\nsecond, so as a 32-bit integer, this will not overflow for 50 days.\r\n\r\nThis function is Wiring-compatible.\r\n\r\n@return the number of milliseconds since the Cortex was turned on","declarations":[{"spell":"1584:15-1584:21|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":101,"usr":8386623308702091189,"detailed_name":"void wait(const unsigned long time)","short_name_offset":5,"short_name_size":4,"kind":12,"storage":1,"hover":"","comments":"\r\nAlias of taskDelay() intended to help EasyC users.\r\n\r\n@param time the duration of the delay in milliseconds (1 000 milliseconds per second)","declarations":[{"spell":"1590:6-1590:10|-1|1|1","param_spellings":["1590:31-1590:35"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":102,"usr":13147995930584246065,"detailed_name":"void waitUntil(unsigned long *previousWakeTime, const unsigned long time)","short_name_offset":5,"short_name_size":9,"kind":12,"storage":1,"hover":"","comments":"\r\nAlias of taskDelayUntil() intended to help EasyC users.\r\n\r\n@param previousWakeTime a pointer to the last wakeup time\r\n@param time the duration of the delay in milliseconds (1 000 milliseconds per second)","declarations":[{"spell":"1597:6-1597:15|-1|1|1","param_spellings":["1597:31-1597:47","1597:69-1597:73"]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":103,"usr":17697071276427321022,"detailed_name":"void watchdogInit()","short_name_offset":5,"short_name_size":12,"kind":12,"storage":1,"hover":"","comments":"\r\nEnables IWDG watchdog timer which will reset the cortex if it locks up due to static shock\r\nor a misbehaving task preventing the timer to be reset. Not recovering from static shock\r\nwill cause the robot to continue moving its motors indefinitely until turned off manually.\r\n\r\nThis function should only be called once in initializeIO()","declarations":[{"spell":"1605:6-1605:18|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":104,"usr":11722135754555131856,"detailed_name":"void standaloneModeEnable()","short_name_offset":5,"short_name_size":20,"kind":12,"storage":1,"hover":"","comments":"\r\nEnables the Cortex to run the op control task in a standalone mode- no VEXnet connection required.\r\n\r\nThis function should only be called once in initializeIO()","declarations":[{"spell":"1611:6-1611:26|-1|1|1","param_spellings":[]}],"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]}],"vars":[{"id":0,"usr":13206646767040568280,"detailed_name":"API_H_","short_name_offset":0,"short_name_size":6,"hover":"#define API_H_","comments":"","declarations":[],"spell":"22:9-22:15|-1|1|2","extent":"22:9-22:15|-1|1|0","uses":[],"kind":255,"storage":0},{"id":1,"usr":13032592422311843347,"detailed_name":"JOY_DOWN","short_name_offset":0,"short_name_size":8,"hover":"#define JOY_DOWN 1","comments":"","declarations":[],"spell":"40:9-40:17|-1|1|2","extent":"40:9-40:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":2,"usr":17880388044063678325,"detailed_name":"JOY_LEFT","short_name_offset":0,"short_name_size":8,"hover":"#define JOY_LEFT 2","comments":"","declarations":[],"spell":"44:9-44:17|-1|1|2","extent":"44:9-44:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":3,"usr":3211327500279121125,"detailed_name":"JOY_UP","short_name_offset":0,"short_name_size":6,"hover":"#define JOY_UP 4","comments":"","declarations":[],"spell":"48:9-48:15|-1|1|2","extent":"48:9-48:17|-1|1|0","uses":[],"kind":255,"storage":0},{"id":4,"usr":17763040893501434648,"detailed_name":"JOY_RIGHT","short_name_offset":0,"short_name_size":9,"hover":"#define JOY_RIGHT 8","comments":"","declarations":[],"spell":"52:9-52:18|-1|1|2","extent":"52:9-52:20|-1|1|0","uses":[],"kind":255,"storage":0},{"id":5,"usr":10348348806393120703,"detailed_name":"ACCEL_X","short_name_offset":0,"short_name_size":7,"hover":"#define ACCEL_X 5","comments":"","declarations":[],"spell":"56:9-56:16|-1|1|2","extent":"56:9-56:18|-1|1|0","uses":[],"kind":255,"storage":0},{"id":6,"usr":3238954955713643999,"detailed_name":"ACCEL_Y","short_name_offset":0,"short_name_size":7,"hover":"#define ACCEL_Y 6","comments":"","declarations":[],"spell":"60:9-60:16|-1|1|2","extent":"60:9-60:18|-1|1|0","uses":[],"kind":255,"storage":0},{"id":7,"usr":9664349553863892910,"detailed_name":"BOARD_NR_ADC_PINS","short_name_offset":0,"short_name_size":17,"hover":"#define BOARD_NR_ADC_PINS 8","comments":"","declarations":[],"spell":"141:9-141:26|-1|1|2","extent":"141:9-141:28|-1|1|0","uses":[],"kind":255,"storage":0},{"id":8,"usr":5830350708685513510,"detailed_name":"BOARD_NR_GPIO_PINS","short_name_offset":0,"short_name_size":18,"hover":"#define BOARD_NR_GPIO_PINS 27","comments":"","declarations":[],"spell":"151:9-151:27|-1|1|2","extent":"151:9-151:30|-1|1|0","uses":[],"kind":255,"storage":0},{"id":9,"usr":17819733132701564002,"detailed_name":"HIGH","short_name_offset":0,"short_name_size":4,"hover":"#define HIGH 1","comments":"","declarations":[],"spell":"157:9-157:13|-1|1|2","extent":"157:9-157:15|-1|1|0","uses":[],"kind":255,"storage":0},{"id":10,"usr":12379678452944744006,"detailed_name":"LOW","short_name_offset":0,"short_name_size":3,"hover":"#define LOW 0","comments":"","declarations":[],"spell":"163:9-163:12|-1|1|2","extent":"163:9-163:14|-1|1|0","uses":[],"kind":255,"storage":0},{"id":11,"usr":12899249389566585217,"detailed_name":"INPUT","short_name_offset":0,"short_name_size":5,"hover":"#define INPUT 0x0A","comments":"","declarations":[],"spell":"172:9-172:14|-1|1|2","extent":"172:9-172:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":12,"usr":6935999971733022112,"detailed_name":"INPUT_ANALOG","short_name_offset":0,"short_name_size":12,"hover":"#define INPUT_ANALOG 0x00","comments":"","declarations":[],"spell":"179:9-179:21|-1|1|2","extent":"179:9-179:26|-1|1|0","uses":[],"kind":255,"storage":0},{"id":13,"usr":17582910714628917707,"detailed_name":"INPUT_FLOATING","short_name_offset":0,"short_name_size":14,"hover":"#define INPUT_FLOATING 0x04","comments":"","declarations":[],"spell":"186:9-186:23|-1|1|2","extent":"186:9-186:28|-1|1|0","uses":[],"kind":255,"storage":0},{"id":14,"usr":2622617720497412693,"detailed_name":"OUTPUT","short_name_offset":0,"short_name_size":6,"hover":"#define OUTPUT 0x01","comments":"","declarations":[],"spell":"193:9-193:15|-1|1|2","extent":"193:9-193:20|-1|1|0","uses":[],"kind":255,"storage":0},{"id":15,"usr":2551837978818003787,"detailed_name":"OUTPUT_OD","short_name_offset":0,"short_name_size":9,"hover":"#define OUTPUT_OD 0x05","comments":"","declarations":[],"spell":"200:9-200:18|-1|1|2","extent":"200:9-200:23|-1|1|0","uses":[],"kind":255,"storage":0},{"id":16,"usr":4048895030180899855,"detailed_name":"INTERRUPT_EDGE_RISING","short_name_offset":0,"short_name_size":21,"hover":"#define INTERRUPT_EDGE_RISING 1","comments":"","declarations":[],"spell":"318:9-318:30|-1|1|2","extent":"318:9-318:32|-1|1|0","uses":[],"kind":255,"storage":0},{"id":17,"usr":13404920296572036684,"detailed_name":"INTERRUPT_EDGE_FALLING","short_name_offset":0,"short_name_size":22,"hover":"#define INTERRUPT_EDGE_FALLING 2","comments":"","declarations":[],"spell":"322:9-322:31|-1|1|2","extent":"322:9-322:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":18,"usr":6904768793225377674,"detailed_name":"INTERRUPT_EDGE_BOTH","short_name_offset":0,"short_name_size":19,"hover":"#define INTERRUPT_EDGE_BOTH 3","comments":"","declarations":[],"spell":"327:9-327:28|-1|1|2","extent":"327:9-327:30|-1|1|0","uses":[],"kind":255,"storage":0},{"id":19,"usr":6485534815130850627,"detailed_name":"IME_ADDR_MAX","short_name_offset":0,"short_name_size":12,"hover":"#define IME_ADDR_MAX 0x1F","comments":"","declarations":[],"spell":"458:9-458:21|-1|1|2","extent":"458:9-458:26|-1|1|0","uses":[],"kind":255,"storage":0},{"id":20,"usr":18343458643485568885,"detailed_name":"ULTRA_BAD_RESPONSE","short_name_offset":0,"short_name_size":18,"hover":"#define ULTRA_BAD_RESPONSE -1","comments":"","declarations":[],"spell":"650:9-650:27|-1|1|2","extent":"650:9-650:30|-1|1|0","uses":[],"kind":255,"storage":0},{"id":21,"usr":10594551935956594173,"detailed_name":"FILE","short_name_offset":0,"short_name_size":4,"hover":"#define FILE PROS_FILE","comments":"","declarations":[],"spell":"759:9-759:13|-1|1|2","extent":"759:9-759:23|-1|1|0","uses":[],"kind":255,"storage":0},{"id":22,"usr":6597765734742690709,"detailed_name":"SERIAL_DATABITS_8","short_name_offset":0,"short_name_size":17,"hover":"#define SERIAL_DATABITS_8 0x0000","comments":"","declarations":[],"spell":"765:9-765:26|-1|1|2","extent":"765:9-765:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":23,"usr":9202971270433232021,"detailed_name":"SERIAL_DATABITS_9","short_name_offset":0,"short_name_size":17,"hover":"#define SERIAL_DATABITS_9 0x1000","comments":"","declarations":[],"spell":"769:9-769:26|-1|1|2","extent":"769:9-769:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":24,"usr":6387706063378726674,"detailed_name":"SERIAL_STOPBITS_1","short_name_offset":0,"short_name_size":17,"hover":"#define SERIAL_STOPBITS_1 0x0000","comments":"","declarations":[],"spell":"773:9-773:26|-1|1|2","extent":"773:9-773:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":25,"usr":17885234768906035586,"detailed_name":"SERIAL_STOPBITS_2","short_name_offset":0,"short_name_size":17,"hover":"#define SERIAL_STOPBITS_2 0x2000","comments":"","declarations":[],"spell":"777:9-777:26|-1|1|2","extent":"777:9-777:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":26,"usr":3559655855214643190,"detailed_name":"SERIAL_PARITY_NONE","short_name_offset":0,"short_name_size":18,"hover":"#define SERIAL_PARITY_NONE 0x0000","comments":"","declarations":[],"spell":"781:9-781:27|-1|1|2","extent":"781:9-781:34|-1|1|0","uses":[],"kind":255,"storage":0},{"id":27,"usr":16790844836152738696,"detailed_name":"SERIAL_PARITY_EVEN","short_name_offset":0,"short_name_size":18,"hover":"#define SERIAL_PARITY_EVEN 0x0400","comments":"","declarations":[],"spell":"785:9-785:27|-1|1|2","extent":"785:9-785:34|-1|1|0","uses":[],"kind":255,"storage":0},{"id":28,"usr":831710818658825986,"detailed_name":"SERIAL_PARITY_ODD","short_name_offset":0,"short_name_size":17,"hover":"#define SERIAL_PARITY_ODD 0x0600","comments":"","declarations":[],"spell":"789:9-789:26|-1|1|2","extent":"789:9-789:33|-1|1|0","uses":[],"kind":255,"storage":0},{"id":29,"usr":18320052049684808542,"detailed_name":"SERIAL_8N1","short_name_offset":0,"short_name_size":10,"hover":"#define SERIAL_8N1 0x0000","comments":"","declarations":[],"spell":"793:9-793:19|-1|1|2","extent":"793:9-793:26|-1|1|0","uses":[],"kind":255,"storage":0},{"id":30,"usr":2129077232960912280,"detailed_name":"stdout","short_name_offset":0,"short_name_size":6,"hover":"#define stdout ((PROS_FILE *)3)","comments":"","declarations":[],"spell":"828:9-828:15|-1|1|2","extent":"828:9-828:32|-1|1|0","uses":[],"kind":255,"storage":0},{"id":31,"usr":17489541512021562151,"detailed_name":"stdin","short_name_offset":0,"short_name_size":5,"hover":"#define stdin ((PROS_FILE *)3)","comments":"","declarations":[],"spell":"832:9-832:14|-1|1|2","extent":"832:9-832:31|-1|1|0","uses":[],"kind":255,"storage":0},{"id":32,"usr":5951592243640023719,"detailed_name":"uart1","short_name_offset":0,"short_name_size":5,"hover":"#define uart1 ((PROS_FILE *)1)","comments":"","declarations":[],"spell":"836:9-836:14|-1|1|2","extent":"836:9-836:31|-1|1|0","uses":[],"kind":255,"storage":0},{"id":33,"usr":5342935855017286525,"detailed_name":"uart2","short_name_offset":0,"short_name_size":5,"hover":"#define uart2 ((PROS_FILE *)2)","comments":"","declarations":[],"spell":"840:9-840:14|-1|1|2","extent":"840:9-840:31|-1|1|0","uses":[],"kind":255,"storage":0},{"id":34,"usr":5134795043880325490,"detailed_name":"EOF","short_name_offset":0,"short_name_size":3,"hover":"#define EOF ((int)-1)","comments":"","declarations":[],"spell":"846:9-846:12|-1|1|2","extent":"846:9-846:22|-1|1|0","uses":[],"kind":255,"storage":0},{"id":35,"usr":12559879245223832265,"detailed_name":"SEEK_SET","short_name_offset":0,"short_name_size":8,"hover":"#define SEEK_SET 0","comments":"","declarations":[],"spell":"854:9-854:17|-1|1|2","extent":"854:9-854:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":36,"usr":7810426061844701541,"detailed_name":"SEEK_CUR","short_name_offset":0,"short_name_size":8,"hover":"#define SEEK_CUR 1","comments":"","declarations":[],"spell":"861:9-861:17|-1|1|2","extent":"861:9-861:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":37,"usr":18327800862976911792,"detailed_name":"SEEK_END","short_name_offset":0,"short_name_size":8,"hover":"#define SEEK_END 2","comments":"","declarations":[],"spell":"868:9-868:17|-1|1|2","extent":"868:9-868:19|-1|1|0","uses":[],"kind":255,"storage":0},{"id":38,"usr":15512720750952290136,"detailed_name":"LCD_BTN_LEFT","short_name_offset":0,"short_name_size":12,"hover":"#define LCD_BTN_LEFT 1","comments":"","declarations":[],"spell":"1140:9-1140:21|-1|1|2","extent":"1140:9-1140:23|-1|1|0","uses":[],"kind":255,"storage":0},{"id":39,"usr":9806856487147182837,"detailed_name":"LCD_BTN_CENTER","short_name_offset":0,"short_name_size":14,"hover":"#define LCD_BTN_CENTER 2","comments":"","declarations":[],"spell":"1144:9-1144:23|-1|1|2","extent":"1144:9-1144:25|-1|1|0","uses":[],"kind":255,"storage":0},{"id":40,"usr":9597283868995028058,"detailed_name":"LCD_BTN_RIGHT","short_name_offset":0,"short_name_size":13,"hover":"#define LCD_BTN_RIGHT 4","comments":"","declarations":[],"spell":"1148:9-1148:22|-1|1|2","extent":"1148:9-1148:24|-1|1|0","uses":[],"kind":255,"storage":0},{"id":41,"usr":1691641261048220876,"detailed_name":"TASK_MAX","short_name_offset":0,"short_name_size":8,"hover":"#define TASK_MAX 16","comments":"","declarations":[],"spell":"1232:9-1232:17|-1|1|2","extent":"1232:9-1232:20|-1|1|0","uses":[],"kind":255,"storage":0},{"id":42,"usr":1820968063246279540,"detailed_name":"TASK_MAX_PRIORITIES","short_name_offset":0,"short_name_size":19,"hover":"#define TASK_MAX_PRIORITIES 6","comments":"","declarations":[],"spell":"1238:9-1238:28|-1|1|2","extent":"1238:9-1238:30|-1|1|0","uses":[],"kind":255,"storage":0},{"id":43,"usr":5729089930071359760,"detailed_name":"TASK_PRIORITY_LOWEST","short_name_offset":0,"short_name_size":20,"hover":"#define TASK_PRIORITY_LOWEST 0","comments":"","declarations":[],"spell":"1243:9-1243:29|-1|1|2","extent":"1243:9-1243:31|-1|1|0","uses":[],"kind":255,"storage":0},{"id":44,"usr":17392446383900694118,"detailed_name":"TASK_PRIORITY_DEFAULT","short_name_offset":0,"short_name_size":21,"hover":"#define TASK_PRIORITY_DEFAULT 2","comments":"","declarations":[],"spell":"1249:9-1249:30|-1|1|2","extent":"1249:9-1249:32|-1|1|0","uses":[],"kind":255,"storage":0},{"id":45,"usr":5399134613041506695,"detailed_name":"TASK_PRIORITY_HIGHEST","short_name_offset":0,"short_name_size":21,"hover":"#define TASK_PRIORITY_HIGHEST (TASK_MAX_PRIORITIES - 1)","comments":"","declarations":[],"spell":"1254:9-1254:30|-1|1|2","extent":"1254:9-1254:56|-1|1|0","uses":[],"kind":255,"storage":0},{"id":46,"usr":8439573005727905084,"detailed_name":"TASK_DEFAULT_STACK_SIZE","short_name_offset":0,"short_name_size":23,"hover":"#define TASK_DEFAULT_STACK_SIZE 512","comments":"","declarations":[],"spell":"1262:9-1262:32|-1|1|2","extent":"1262:9-1262:36|-1|1|0","uses":[],"kind":255,"storage":0},{"id":47,"usr":377882829957863227,"detailed_name":"TASK_MINIMAL_STACK_SIZE","short_name_offset":0,"short_name_size":23,"hover":"#define TASK_MINIMAL_STACK_SIZE 64","comments":"","declarations":[],"spell":"1270:9-1270:32|-1|1|2","extent":"1270:9-1270:35|-1|1|0","uses":[],"kind":255,"storage":0},{"id":48,"usr":13815218972527606391,"detailed_name":"TASK_DEAD","short_name_offset":0,"short_name_size":9,"hover":"#define TASK_DEAD 0","comments":"","declarations":[],"spell":"1275:9-1275:18|-1|1|2","extent":"1275:9-1275:20|-1|1|0","uses":[],"kind":255,"storage":0},{"id":49,"usr":17001838848826513297,"detailed_name":"TASK_RUNNING","short_name_offset":0,"short_name_size":12,"hover":"#define TASK_RUNNING 1","comments":"","declarations":[],"spell":"1279:9-1279:21|-1|1|2","extent":"1279:9-1279:23|-1|1|0","uses":[],"kind":255,"storage":0},{"id":50,"usr":13408960382209097344,"detailed_name":"TASK_RUNNABLE","short_name_offset":0,"short_name_size":13,"hover":"#define TASK_RUNNABLE 2","comments":"","declarations":[],"spell":"1284:9-1284:22|-1|1|2","extent":"1284:9-1284:24|-1|1|0","uses":[],"kind":255,"storage":0},{"id":51,"usr":4124101597773108338,"detailed_name":"TASK_SLEEPING","short_name_offset":0,"short_name_size":13,"hover":"#define TASK_SLEEPING 3","comments":"","declarations":[],"spell":"1289:9-1289:22|-1|1|2","extent":"1289:9-1289:24|-1|1|0","uses":[],"kind":255,"storage":0},{"id":52,"usr":3488568960661521433,"detailed_name":"TASK_SUSPENDED","short_name_offset":0,"short_name_size":14,"hover":"#define TASK_SUSPENDED 4","comments":"","declarations":[],"spell":"1293:9-1293:23|-1|1|2","extent":"1293:9-1293:25|-1|1|0","uses":[],"kind":255,"storage":0}]}