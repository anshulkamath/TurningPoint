#include "robot-config.h"
#include <string>
#include <iostream>
#include <vector>
#include <math.h>
#include <sstream>

using namespace std;
using namespace vex;
double PI = 3.1415;
double wheelDiameter = 4;
double wheelBaseLength = 9.5;
double turnLimiter = .75;
string toString1(double val)
{
    ostringstream v;
    v << val;
    return v.str();
}     
string side = "RED";

void sideSelect()
{
    int pressX = Brain.Screen.xPosition();
    int pressY = Brain.Screen.yPosition();
    
    if(pressX < 100) side = "BLUE";
    if(pressX > 100) side = "RED";
    /*if(side == "BLUE")
        Vision.setLedColor(vex::color::blue);
    if(side == "RED")
        Vision.setLedColor(vex::color::red);*/
    Brain.Screen.clearScreen();
    Brain.Screen.print(("Side: " + side).c_str());
    
    
}

void pre_auton( void ) {   

    Brain.Screen.setPenColor(vex::color::blue);
    Brain.Screen.drawRectangle(0, 0, 100, 100, vex::color::blue);
    Brain.Screen.drawRectangle(101, 0, 100, 100, vex::color::red); 
    Brain.Screen.pressed(sideSelect);
}

void forward(double inches, double speed = 70)
{
    double rots = inches/(wheelDiameter*PI);
    FrontLeft.rotateFor(rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
  
    BackLeft.rotateFor(rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, true);    
}

void backward(double inches, double speed = 50)
{
    double rots = inches/(wheelDiameter*PI);
    FrontLeft.rotateFor(-rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(-rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    
    BackLeft.rotateFor(-rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    BackRight.rotateFor(-rots, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, true);        
}

void turnLeft(double degrees)
{
    double rots = (degrees/360) * ((wheelBaseLength*PI)/(wheelDiameter*PI)) * 90/86;
    
    FrontLeft.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, true);    
}

void turnRight(double degrees)
{
    double rots = (degrees/360) * ((wheelBaseLength*PI)/(wheelDiameter*PI)) * 90/86;
    
    FrontLeft.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackRight.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, true);    
}


bool inUse = false;
bool inTakeInUse = false;
bool fire = false;
int taskShooter()
{
    while(true)
    {
        if(Controller1.ButtonX.pressing() || fire)
        {
            fire = false;
            inUse = true;
            Shooter.spin(directionType::fwd, 100, velocityUnits::pct);
            while(Limit1.pressing());
            bool notTop = false;
            while(!Limit1.pressing())
            {
                notTop = true;
            }
            
            Shooter.stop();
            inUse = false;
        }       
        
    }
    return 0;
}

void autonFunc1(string side)
{
    //task intakeTask = task(intakeControl);
    task shooterTask = task(taskShooter, 1);
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    //Shooter.setStopping(brakeType::hold);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    fire = true;
    backward(36, 40);
    
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(300);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    task::sleep(1000);    
    
    if(side == "RED")
    {
        forward(43.5, 40);
        task::sleep(600);
        backward(8);
        turnRight(100);
    }
    else
    {
        forward(26.5);
        task::sleep(300);        
        turnLeft(90);
    }
    //Brain.resetTimer();
    //while(!Limit2.pressing() || Brain.timer(timeUnits::msec) < 700);
    Intake.spin(directionType::rev, 100, velocityUnits::pct);
    task::sleep(250);
    //while(runVision("BLUE") == -1);
    forward(20, 40);
    task::sleep(500);
    Shooter.rotateFor(200, rotationUnits::deg, 100, velocityUnits::pct);
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    if(side == "RED")
    {
        turnLeft(10);
    }else
        turnRight(15);
    task::sleep(1000);
    forward(53, 100);
}
void autonFunc2(string side)
{
    //task intakeTask = task(intakeControl);
    task shooterTask = task(taskShooter, 1);
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    //Shooter.setStopping(brakeType::hold);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    fire = true;
    backward(36, 40);
    
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(300);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    task::sleep(1000);    
    
    if(side == "RED")
    {
        forward(43.5, 40);
        task::sleep(600);
        backward(8);
        turnRight(100);
    }
    else
    {
        forward(26.5);
        task::sleep(300);        
        turnLeft(90);
    }
    //Brain.resetTimer();
    //while(!Limit2.pressing() || Brain.timer(timeUnits::msec) < 700);
    Intake.spin(directionType::rev, 100, velocityUnits::pct);
    task::sleep(250);
    //while(runVision("BLUE") == -1);
    forward(20, 40);
    task::sleep(500);
    Shooter.rotateFor(200, rotationUnits::deg, 100, velocityUnits::pct);
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    if(side == "RED")
    {
        turnRight(55.5);
    }else
    {
        turnLeft(55.5);
    }
    Flipper.rotateFor(50, rotationUnits::deg, 100, velocityUnits::pct);
    forward(34, 50);
    Flipper.rotateFor(-25, rotationUnits::deg, 100, velocityUnits::pct);  
    
}

void autonomous( void ) {
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    //turnRight(90);
    autonFunc1(side);
    //auton2(side);
    //autoFuncBack("RED");
}

void usercontrol() {

    vex::task(taskShooter, 1);
    bool strafing = false;
    bool slow = false;

    
    bool braked = false;
    Controller1.Screen.clearScreen();
    //while(GyroS.isCalibrating() || GyroI.isCalibrating());
    while(true)
    {  
        int frontLeftValue = 0, frontRightValue = 0, backLeftValue = 0, backRightValue = 0;
        
        if ( abs(Controller1.Axis3.value()) > 20)
        {
            frontLeftValue = Controller1.Axis3.value();
            backLeftValue = Controller1.Axis3.value();  
            strafing = false;
        }
           
        if (abs(Controller1.Axis2.value()) > 20)
        {
            frontRightValue = Controller1.Axis2.value();
            backRightValue = frontRightValue;
            strafing = false;
        }
        
        if(abs(Controller1.Axis3.value() - Controller1.Axis2.value()) > 50)
        {
            frontLeftValue *= turnLimiter;
            frontRightValue *= turnLimiter;
            backRightValue *= turnLimiter;
            backLeftValue *= turnLimiter;
        }
        
        
   
        
       
        if (slow)
        {
            frontRightValue /= 4;
            backLeftValue /= 4;
            backRightValue /=4;
            frontLeftValue /=4;
        }        
        if(Controller1.ButtonRight.pressing())
        {
            if(!braked) 
            {
                FrontLeft.stop(brakeType::hold);
                FrontRight.stop(brakeType::hold);
                BackLeft.stop(brakeType::hold);
                BackRight.stop(brakeType::hold);    
            }
            else
            {
                FrontLeft.setStopping(brakeType::coast);
                FrontRight.setStopping(brakeType::coast);
                BackLeft.setStopping(brakeType::coast);
                BackRight.setStopping(brakeType::coast);                 
            }
            braked = !braked;
            
            while(Controller1.ButtonDown.pressing()){}
        }
        
        if (Controller1.ButtonLeft.pressing())
        {
            slow = !slow;
            while(Controller1.ButtonUp.pressing()){}
        }
        
        if (Controller1.ButtonY.pressing())
            Shooter.spin(directionType::fwd, 60, velocityUnits::pct);
        else if(!inUse)
            Shooter.stop(brakeType::coast);
        

        
        if (Controller1.ButtonL1.pressing())
            Intake.spin(directionType::fwd, 100, velocityUnits::pct);
        
        else if(Controller1.ButtonL2.pressing())
            Intake.spin(directionType::rev, 100, velocityUnits::pct);
        
        else if(!inTakeInUse)
            Intake.stop(brakeType::hold);
       if(Controller1.ButtonUp.pressing())
       {
           Flipper.spin(directionType::fwd, 100, velocityUnits::pct);
       }else if(Controller1.ButtonDown.pressing())
           Flipper.spin(directionType::rev, 100, velocityUnits::pct);
       else
           Flipper.stop();
       
        FrontLeft.spin(directionType::fwd, frontLeftValue, velocityUnits::pct);
        FrontRight.spin(directionType::fwd, frontRightValue, velocityUnits::pct);       
        BackRight.spin(directionType::fwd, backRightValue, velocityUnits::pct);
        BackLeft.spin(directionType::fwd,  backLeftValue, velocityUnits::pct);     
        
      
        Controller1.Screen.clearLine();
        //Controller1.Screen.print(val1.c_str());       

        
        string isSlow = "Slow: " + toString1(slow) + " " + "Brake: " + toString1(braked);
        isSlow = toString1(Shooter.rotation(rotationUnits::deg));
        Controller1.Screen.print(isSlow.c_str());
        
        task::sleep(20);
    }
}

int main() {
    
    //Run the pre-autonomous function. 
    pre_auton();
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous( autonomous );
    Competition.drivercontrol( usercontrol );

    //Prevent main from exiting with an infinite loop.                        
    while(1) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
    return 0;
       
}
