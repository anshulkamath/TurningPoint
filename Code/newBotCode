#include "robot-config.h"
#include <string>
#include <iostream>
#include <vector>
#include <math.h>
#include <sstream>

using namespace std;
using namespace vex;

// Global Variables
double PI = 3.1415;
double wheelDiameter = 4;
double wheelBaseLength = 9.5;

// Auton Selector
string side = "RED";
int autonNum = 0; // 0 is close to flags, 1 is far from flags
bool park = false;

string toString1(double val)
{
    ostringstream v;
    v << val;
    return v.str();
}     

void sideSelect()
{
    if(Brain.Screen.xPosition() <= 240) side = "BLUE";
    else if(Brain.Screen.xPosition() >= 241) side = "RED";
}

void autonSelect()
{
    if(Brain.Screen.xPosition() <= 240) autonNum = 0;
    else if(Brain.Screen.xPosition() >= 241) autonNum = 1;
}

void autonPark()
{
    if (Brain.Screen.xPosition() <= 240) park = true;
    else if (Brain.Screen.xPosition() > 240) park = false;
}

void pre_auton( void )
{   
    // Brain Screen: 480 x 272
    Brain.Screen.clearScreen();
    Brain.Screen.setPenColor(vex::color::black);
    Brain.Screen.drawRectangle(0, 0, 240, 272, vex::color::blue);
    Brain.Screen.drawRectangle(241, 0, 480, 272, vex::color::red);
    Brain.Screen.pressed(sideSelect);
    
    Brain.Screen.clearScreen();
    Brain.Screen.setPenColor(vex::color::red);
    Brain.Screen.drawRectangle(0, 0, 240, 272, vex::color::white);
    Brain.Screen.drawRectangle(241, 0, 480, 272, vex::color::black);
    Brain.Screen.printAt(100, 136, "FRONT");
    Brain.Screen.printAt(340, 136, "BACK");
    Brain.Screen.pressed(autonSelect);
   
    Brain.Screen.clearScreen();
    Brain.Screen.drawLine(240, 0, 240, 480);
    Brain.Screen.printAt(100, 136, "PARK");
    Brain.Screen.printAt(340, 136, "NO PARK");
    Brain.Screen.pressed(autonPark);
}

void ramp(int vel, int cycles, double inches, bool rampUp = true)
{
    FrontLeft.setStopping(brakeType::coast);
    FrontRight.setStopping(brakeType::coast);
    BackLeft.setStopping(brakeType::coast);
    BackRight.setStopping(brakeType::coast); 
    
    // rampUp assumes going to or coming from 0
    double rots = inches / (wheelDiameter * PI);
    double rotsPerCycle = rots / cycles;
    
    // setting rotations to negative to account for moving backwards
    if (vel < 0) rots *= -1;
    
    for (int i = 0; i < cycles; i++)
    {
        double targVel;
        
        // setting the velocity based on the iteration of the loop
        if (rampUp) 
            targVel = vel / cycles * (i + 1);
        else
            targVel = vel - (vel / cycles * (i + 1));
        
        // actual control of the motors per cycle
        FrontLeft.rotateFor(rotsPerCycle, rotationUnits::rev, targVel, velocityUnits::pct, true);
        BackLeft.rotateFor(rotsPerCycle, rotationUnits::rev, targVel, velocityUnits::pct, true);
        FrontRight.rotateFor(rotsPerCycle, rotationUnits::rev, targVel, velocityUnits::pct, true);
        BackRight.rotateFor(rotsPerCycle, rotationUnits::rev, targVel, velocityUnits::pct, true);
    }
}

void forward1(double inches, double speed = 70)
{
     FrontLeft.setStopping(brakeType::coast);
        FrontRight.setStopping(brakeType::coast);
        BackLeft.setStopping(brakeType::coast);
        BackRight.setStopping(brakeType::coast);         
    double rots = inches/(wheelDiameter*PI);
    double start = FrontLeft.rotation(rotationUnits::rev);
    /*FrontLeft.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, true);*/
    while(FrontLeft.rotation(rotationUnits::rev) - start < rots)
    {
        double frac = (FrontLeft.rotation(rotationUnits::rev) - start)/(start + rots);
        double speeddy = 1- 16*(pow(frac-.5, 2));
        FrontLeft.spin(directionType::fwd, speeddy*speed, velocityUnits::pct);
        FrontRight.spin(directionType::fwd, speeddy*speed, velocityUnits::pct);
        BackLeft.spin(directionType::fwd, speeddy*speed, velocityUnits::pct);
        BackRight.spin(directionType::fwd, speeddy*speed, velocityUnits::pct);
        
    }
        FrontLeft.stop(brakeType::coast);
        FrontRight.stop(brakeType::coast);
        BackLeft.stop(brakeType::coast);
        BackRight.stop(brakeType::coast);
}

void backward1(double inches, double speed = 70)
{
     FrontLeft.setStopping(brakeType::coast);
        FrontRight.setStopping(brakeType::coast);
        BackLeft.setStopping(brakeType::coast);
        BackRight.setStopping(brakeType::coast);         
    double rots = inches/(wheelDiameter*PI);
    double start = FrontLeft.rotation(rotationUnits::rev);
    /*FrontLeft.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots, vex::rotationUnits::rev, speed/8, vex::velocityUnits::pct, true);*/
    while(FrontLeft.rotation(rotationUnits::rev) - start > -rots)
    {
        double frac = (FrontLeft.rotation(rotationUnits::rev) - start)/(start - rots);
        double speeddy = 1- 16*(pow(frac-.5, 2));

        FrontRight.spin(directionType::rev, speeddy*speed, velocityUnits::pct);
        BackLeft.spin(directionType::rev, speeddy*speed, velocityUnits::pct);
        BackRight.spin(directionType::rev, speeddy*speed, velocityUnits::pct);
        FrontLeft.spin(directionType::rev, speeddy*speed, velocityUnits::pct);        
        
    }
        FrontLeft.stop(brakeType::coast);
        FrontRight.stop(brakeType::coast);
        BackLeft.stop(brakeType::coast);
        BackRight.stop(brakeType::coast);
}
void forward(double inches, double speed = 70)
{
     FrontLeft.setStopping(brakeType::coast);
        FrontRight.setStopping(brakeType::coast);
        BackLeft.setStopping(brakeType::coast);
        BackRight.setStopping(brakeType::coast);         
    double rots = inches/(wheelDiameter*PI);
    double rampConst = (double)(200) / 360;
    if (rots < rampConst*2.5)
        rampConst = 0;
    FrontLeft.rotateFor(rampConst, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rampConst, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rampConst, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rampConst, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, true);
    
    FrontLeft.rotateFor(rots - 2.5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots - 2.5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rots - 2.5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots - 2.5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct, true);
        FrontLeft.setStopping(brakeType::coast);
        FrontRight.setStopping(brakeType::coast);
        BackLeft.setStopping(brakeType::coast);
        BackRight.setStopping(brakeType::coast);   
   FrontLeft.rotateFor(rampConst*1.5, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
   FrontRight.rotateFor(rampConst*1.5, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rampConst*1.5, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rampConst*1.5, vex::rotationUnits::rev, speed / 2, vex::velocityUnits::pct, true);
}

void backward(double inches, double speed = 50)
{
    
        FrontLeft.setStopping(brakeType::coast);
        FrontRight.setStopping(brakeType::coast);
        BackLeft.setStopping(brakeType::coast);
        BackRight.setStopping(brakeType::coast);      
    double rots = inches/(wheelDiameter*PI);
    double rampConst = (double)(300) / 360;
    if (rots < rampConst*3)
        rampConst = 0;
    FrontLeft.resetRotation();
    FrontLeft.startRotateFor(-rampConst, vex::rotationUnits::rev, 8, vex::velocityUnits::pct);
    FrontRight.startRotateFor(-rampConst, vex::rotationUnits::rev, 8, vex::velocityUnits::pct);
    BackLeft.startRotateFor(-rampConst, vex::rotationUnits::rev, 8, vex::velocityUnits::pct);
    BackRight.startRotateFor(-rampConst, vex::rotationUnits::rev, 8, vex::velocityUnits::pct);    
    while(FrontLeft.isSpinning())
    {
       FrontLeft.setVelocity(fabs(FrontLeft.rotation(rotationUnits::rev)/rampConst) * speed, velocityUnits::pct);
       FrontRight.setVelocity(fabs(FrontLeft.rotation(rotationUnits::rev)/rampConst) * speed, velocityUnits::pct);
       BackLeft.setVelocity(fabs(FrontLeft.rotation(rotationUnits::rev)/rampConst) * speed, velocityUnits::pct);
       BackRight.setVelocity(fabs(FrontLeft.rotation(rotationUnits::rev)/rampConst) * speed, velocityUnits::pct);        
    }
    FrontLeft.startRotateFor(-rots + 5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    FrontRight.startRotateFor(-rots + 5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    BackLeft.startRotateFor(-rots + 5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    BackRight.startRotateFor(-rots + 5*rampConst, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    while(FrontLeft.isSpinning());
    FrontRight.resetRotation();
    FrontLeft.startRotateFor(-rampConst*4, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    FrontRight.startRotateFor(-rampConst*4, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    BackLeft.startRotateFor(-rampConst*4, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    BackRight.startRotateFor(-rampConst*4, vex::rotationUnits::rev, speed, vex::velocityUnits::pct);
    while(FrontRight.isSpinning())
    {
       FrontLeft.setVelocity((1-fabs(FrontRight.rotation(rotationUnits::rev)/(rampConst*4))) * speed, velocityUnits::pct);
       FrontRight.setVelocity((1-fabs(FrontRight.rotation(rotationUnits::rev)/(rampConst*4))) * speed, velocityUnits::pct);
       BackLeft.setVelocity((1-fabs(FrontRight.rotation(rotationUnits::rev)/(rampConst*4))) * speed, velocityUnits::pct);
       BackRight.setVelocity((1-fabs(FrontRight.rotation(rotationUnits::rev)/(rampConst*4))) * speed, velocityUnits::pct);        
    }    
}

void turnLeft(double degrees)
{
    double rots = (degrees/360) * ((wheelBaseLength*PI)/(wheelDiameter*PI)) * 90/86;
    
    FrontLeft.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackRight.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, true);    
}

void turnRight(double degrees)
{
    double rots = (degrees/360) * ((wheelBaseLength*PI)/(wheelDiameter*PI)) * 90/86;
    
    FrontLeft.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackLeft.rotateFor(rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    FrontRight.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, false);
    BackRight.rotateFor(-rots, vex::rotationUnits::rev, 35, vex::velocityUnits::pct, true);    
}

// Tasks


// Drive Variables
double turnLimiter = .6;
bool braked = false;
bool inverted = false;

int sign(double val)
{
    return val < 0 ? -1 : 1;
}

// Drive Task
int taskDrive()
{
    while (true)
    {
        int frontLeftValue = 0, 
            frontRightValue = 0, 
            backLeftValue = 0, 
            backRightValue = 0;        
        // Constant Straight Drive Control
        if (Controller1.ButtonR1.pressing())
            frontLeftValue = frontRightValue = backLeftValue = backRightValue = 40;
        else if (Controller1.ButtonR2.pressing())
            frontLeftValue = frontRightValue = backLeftValue = backRightValue = -40;       
        
        // Throttled Tank Drive Controls
        else
        {
            // Scale = x^2/100
            if (abs(Controller1.Axis2.value()) > 20)
            {
                frontRightValue = Controller1.Axis2.value() / 1;
                backRightValue = frontRightValue;
            }
            if (abs(Controller1.Axis3.value()) > 20)
            {
                frontLeftValue  = Controller1.Axis3.value() / 1;
                backLeftValue = frontLeftValue;
            }
        }
        if(abs(abs(Controller1.Axis2.value()) - abs(Controller1.Axis3.value())) > 20)
        {
            frontLeftValue = backLeftValue = Controller1.Axis3.value();
            frontRightValue = backRightValue = Controller1.Axis2.value();
        }
        // Throttling Turns
        if(abs(Controller1.Axis2.value() - Controller1.Axis3.value()) > 50)
        {
            frontLeftValue = backLeftValue *= turnLimiter; 
            frontRightValue = backRightValue *= turnLimiter; 
        }

        // Inverting Drive
        /*if(Controller1.ButtonLeft.pressing())
        {
            frontLeftValue = backLeftValue *= -1;
            backRightValue = frontRightValue *= -1;
            
            inverted = !inverted;
            while (Controller1.ButtonL1.pressing());
        }*/
        
        // Enables Brake Mode
        if (Controller1.ButtonDown.pressing())
        {
            if(!braked) 
            {
                FrontLeft.setStopping(brakeType::hold);
                FrontRight.setStopping(brakeType::hold);
                BackLeft.setStopping(brakeType::hold);
                BackRight.setStopping(brakeType::hold);    
            }
            else
            {
                FrontLeft.setStopping(brakeType::coast);
                FrontRight.setStopping(brakeType::coast);
                BackLeft.setStopping(brakeType::coast);
                BackRight.setStopping(brakeType::coast);                 
            }
            braked = !braked;
            
            while (Controller1.ButtonDown.pressing());
        }
        
        // Sets Motor Powers
        FrontLeft.spin(directionType::fwd, frontLeftValue, velocityUnits::pct);
        FrontRight.spin(directionType::fwd, frontRightValue, velocityUnits::pct);
        BackLeft.spin(directionType::fwd, backLeftValue, velocityUnits::pct);
        BackRight.spin(directionType::fwd, backRightValue, velocityUnits::pct);
        
        task::sleep(20);
    }
    return 0;
}

// Shooter Variables
bool inUse = false;
bool inTakeInUse = false;
bool fire = false;
bool catapultDown = false;

// Shooter Task
int taskShooter()
{
    while(true)
    {
        if(Controller1.ButtonX.pressing() || fire)
        {
            fire = false;
            inUse = true;
            // Rotates until slip
            Shooter.rotateFor(100, rotationUnits::raw, 100, velocityUnits::pct);
            ShooterAux.rotateFor(100, rotationUnits::raw, 100, velocityUnits::pct);
            
            // Rotates back to original position
            Shooter.spin(directionType::fwd, 100, velocityUnits::pct);
            ShooterAux.spin(directionType::fwd, 100, velocityUnits::pct);
            while(Limit1.pressing() && inUse); // assumes that catapult starts in the up position
            catapultDown = false;
            while(!Limit1.pressing() && inUse) {};
            catapultDown = true;
            
            Shooter.stop();
            inUse = false;
        }
        
        
    }
    return 0;
}

int taskIntakes()
{
    while (true)
    {
        // Controls intake
        if (Controller1.ButtonL1.pressing() && catapultDown)
            Intake.spin(directionType::fwd, 100, velocityUnits::pct);
        else if(Controller1.ButtonL2.pressing())
            Intake.spin(directionType::rev, 100, velocityUnits::pct);
        else if(!inTakeInUse)
            Intake.stop(brakeType::hold);
    }
    return 0;
}

// Front - 3 Flags 1 Cap
void autonFunc1(string side)
{
    // Setup for Auton
    task shooterTask = task(taskShooter, 1);
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    
    
   // fire = true;
    backward(36, 40); // Back into the ball
    
    task::sleep(600); // Wait for ball to get into intake
    
    forward(47, 100); // Drive into wall and 0
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(600);
    backward(8,30); // Drive backwards to aim at flags
    
    /*if(side == "RED")
        turnRight(95);
    else
        turnLeft(95);*/
    turnRight(90);
    
    forward(25, 30); // Shoot flags
    task::sleep(250);
    Shooter.rotateFor(400, rotationUnits::deg, 100, velocityUnits::pct);
   
    
    if(side == "RED")
        turnLeft(20);
    else
        turnRight(15);
    task::sleep(1000);
    forward(53, 100); // Drive into bottom flags
}

// Front - 2 Flags 2 Caps
void autonFunc2(string side)
{
    // Setup
    task shooterTask = task(taskShooter, 1);
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    
    // Set up catapult and back into the ball
    fire = true;
    backward(36, 40);
    
    // Intake the ball and flip the cap
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(300);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    task::sleep(600);    
    
    // Forward, center on wall, backwards
    forward(43.5, 80);
    task::sleep(600);
    backward(8);

    // Turn towards flags
    if(side == "RED")
        turnRight(100);
    else
        turnLeft(100);

    // Forward to get into position to shoot
    forward(20, 40);
    task::sleep(250);
    
    // Fire
    Shooter.rotateFor(200, rotationUnits::deg, 100, velocityUnits::pct);
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    
    // Turn towards the next cap
    if(side == "RED")
        turnRight(55.5);
    else
        turnLeft(55.5);
    
    // Rotate the flipper down to get the cap
    Flipper.rotateFor(50, rotationUnits::deg, 100, velocityUnits::pct);
    
    // Drive into the cap
    forward(34, 50);
    
    // Flip the cap
    Flipper.rotateFor(-25, rotationUnits::deg, 100, velocityUnits::pct);  
    
}

// Back - Flip Caps
void autonFunc3(string side)
{
    // Setup
    task shooterTask = task(taskShooter, 1);
    FrontLeft.setStopping(brakeType::brake);
    FrontRight.setStopping(brakeType::brake);
    BackLeft.setStopping(brakeType::brake);
    BackRight.setStopping(brakeType::brake);    
    
    // Set up catapult and back into the ball
    fire = true;
    backward(36, 40);
    
    // Intake the ball and flip the cap
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(300);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    task::sleep(600);
    Intake.stop(brakeType::coast);
    
    // Forward half and turn into the next cap
    forward(6, 50);
    
    side == "RED" ? turnRight(35) : turnLeft(35);
    
    if (side == "RED")
        turnRight(35);
    else
        turnLeft(35);
    
    // Reverse into the cap to flip it
    Intake.spin(directionType::rev);
    backward(15, 60);
    
    // Position to park
    if (park)
    {
        forward(7, 50);
        turnRight(65);
        forward(20, 60);
    }
}
void autonFunc4(string side)
{  
    backward(36, 40);    
    Intake.spin(directionType::fwd, 0, velocityUnits::pct);
    task::sleep(300);
    Intake.spin(directionType::fwd, 100, velocityUnits::pct);
    task::sleep(1000);
    Intake.stop(brakeType::coast);  
    forward(10, 40);
    turnLeft(90);
    forward(30, 100);
    
}
void autonomous( void ) {
    FrontLeft.setStopping(brakeType::coast);
    FrontRight.setStopping(brakeType::coast);
    BackLeft.setStopping(brakeType::coast);
    BackRight.setStopping(brakeType::coast);    
    backward(20, 100);
    task::sleep(1000);
    forward(20, 100);
    //autonFunc1(side);
    //autonFunc4(side);
}

void usercontrol() {

    vex::task(taskShooter, 1);
    vex::task(taskDrive, 1);
    vex::task(taskIntakes, 1);
     FrontLeft.setStopping(brakeType::coast);
    FrontRight.setStopping(brakeType::coast);
    BackLeft.setStopping(brakeType::coast);
    BackRight.setStopping(brakeType::coast);   
    Controller1.Screen.clearScreen();
    while(true)
    {   
        if (Controller1.ButtonY.pressing())
        {
            Shooter.spin(directionType::fwd, 60, velocityUnits::pct);
            ShooterAux.spin(directionType::fwd, 60, velocityUnits::pct);
        }
        else if(!inUse)
        {
            Shooter.stop(brakeType::coast);
            ShooterAux.stop(brakeType::coast);
        }
        else if(Controller1.ButtonA.pressing())
        {
            Shooter.stop(brakeType::coast);
            ShooterAux.stop(brakeType::coast);  
            inUse = false;
        }
        
        Controller1.Screen.print("Braked: %d", braked);        
        Controller1.Screen.newLine();
        Controller1.Screen.print("Inverted: %d", inverted);        
        Controller1.Screen.newLine();
        int temp = Brain.Battery.capacity(percentUnits::pct);
        Controller1.Screen.print("Battery: %d", temp);        

        task::sleep(1000);
    }
}

int main() {
    
    //Run the pre-autonomous function. 
    pre_auton();
    
    //Set up callbacks for autonomous and driver control periods.
    Competition.autonomous( autonomous );
    Competition.drivercontrol( usercontrol );

    //Prevent main from exiting with an infinite loop.                        
    while(1) {
      vex::task::sleep(100);//Sleep the task for a short amount of time to prevent wasted resources.
    }    
    return 0;
       
}
